{"version":3,"file":"workers/mainworker.js","mappings":"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","sources":["webpack://math-util/./src/scripts/subworkerspolyfill.js","webpack://math-util/webpack/bootstrap","webpack://math-util/./src/scripts/workers/mainWorker.ts","webpack://math-util/./src/scripts/app_util.ts"],"sourcesContent":["module.exports = function(){\r\n\r\n  /* Detect if we're in a worker or not */\r\n  var isWorker = false;\r\n  try {\r\n    document;\r\n  } catch (e){\r\n    isWorker = true;\r\n  }\r\n\r\n  if (isWorker){\r\n    if (!self.Worker){\r\n      self.Worker = function(path){\r\n        this.id = Math.random().toString(36).substr(2, 5);\r\n        this.eventListeners = {\r\n          \"message\": [],\r\n          error: []\r\n        };\r\n        self.addEventListener(\"message\", function(e){\r\n          if (e.data._from === this.id){\r\n        \t  if(e.data.cmd==\"passMessage\"){\r\n        \t\t  var relayEvent = new MessageEvent(\"message\");\r\n                  relayEvent.initMessageEvent(\"message\", false, false, e.data.message, this, \"\", null, []);\r\n                  this.dispatchEvent(relayEvent);\r\n                  if (this.onmessage){\r\n                    this.onmessage(relayEvent);\r\n                  }\r\n        \t  }\r\n        \t  if(e.data.cmd==\"passError\"){\r\n        \t\t  var relayEvent = Object.assign(new Event(\"error\"), e.data.errorProperties);\r\n        \t\t  this.dispatchEvent(relayEvent)\r\n        \t\t  if(this.onerror){\r\n        \t\t\t  this.onerror(relayEvent);\r\n        \t\t  }\r\n        \t  }\r\n          }\r\n        }.bind(this));\r\n        var location = self.location.pathname;\r\n        var absPath = location.substring(0, location.lastIndexOf('/')) + '/' + path;\r\n        self.postMessage({\r\n          _subworker: true,\r\n          cmd: 'newWorker',\r\n          id: this.id,\r\n          path: absPath\r\n        });\r\n      };\r\n      Worker.prototype = {\r\n        onerror: null,\r\n        onmessage: null,\r\n        postMessage: function(message){\r\n          self.postMessage({\r\n            _subworker: true,\r\n            id: this.id,\r\n            cmd: 'passMessage',\r\n            message: message\r\n          });\r\n        },\r\n        terminate: function(){\r\n          self.postMessage({\r\n            _subworker: true,\r\n            cmd: 'terminate',\r\n            id: this.id\r\n          });\r\n        },\r\n        addEventListener: function(type, listener, useCapture){\r\n          if (this.eventListeners[type]){\r\n            this.eventListeners[type].push(listener);\r\n          }\r\n        },\r\n        removeEventListener: function(type, listener, useCapture){\r\n          if (!(type in this.eventListeners)) {\r\n            return;\r\n          }\r\n          var index = this.eventListeners[type].indexOf(listener);\r\n          if (index !== -1){\r\n            this.eventListeners[type].splice(index, 1);\r\n          }\r\n        },\r\n        dispatchEvent: function(event){\r\n          var listeners = this.eventListeners[event.type];\r\n          for (var i = 0; i < listeners.length; i++) {\r\n            listeners[i](event);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  }\r\n  else{\r\n  var allWorkers = {};\r\n  var cmds = {\r\n    newWorker: function(event){\r\n      var workerId = event.data.id;\r\n      var worker = new Worker(event.data.path);\r\n      worker.addEventListener(\"message\", function(e){\r\n        var envelope = {\r\n          _subworker: true,\r\n          _from: workerId,\r\n          message: e.data,\r\n          cmd: \"passMessage\"\r\n        }\r\n        event.target.postMessage(envelope);\r\n      });\r\n      \r\n      worker.addEventListener(\"error\", function(e){\r\n          var envelope = {\r\n        \t_subworker:true,\r\n            _from: workerId,\r\n            errorProperties:{message: e.message, lineno: e.lineno, filename: e.filename, colno: e.colno},\r\n            cmd: \"passError\"\r\n          }\r\n          event.target.postMessage(envelope);\r\n        });\r\n      \r\n      allWorkers[workerId] = worker;\r\n    },\r\n    terminate: function(event){\r\n      allWorkers[event.data.id].terminate();\r\n    },\r\n    passMessage: function(event){\r\n      allWorkers[event.data.id].postMessage(event.data.message);\r\n    }\r\n  }\r\n  var messageRecieved = function(event){\r\n    if (event.data._subworker){\r\n      cmds[event.data.cmd](event);\r\n    }\r\n  };\r\n\r\n\r\n  /* Hijack Worker */\r\n  var oldWorker = Worker;\r\n  Worker = function(path){\r\n    if (this.constructor !== Worker){\r\n      throw new TypeError(\"Failed to construct 'Worker': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\r\n    }\r\n\r\n    var blobIndex = path.indexOf('blob:');\r\n    \r\n    if (blobIndex !== -1 && blobIndex !== 0 ) {\r\n      path = path.substring(blobIndex);\r\n    }\r\n\r\n    var newWorker = new oldWorker(path);\r\n    newWorker.addEventListener(\"message\", messageRecieved);\r\n\r\n    return newWorker;\r\n  };\r\n\r\n}}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { createWorker } from \"../app_util\"\r\nrequire(\"../subworkerspolyfill\")();\r\nconst workers: { [functionName: string]: Worker } = {};\r\nonmessage = async function (message) {\r\n\tvar funcName = message.data.funcName;\r\n\tif (!(workers[funcName])) {\r\n\t\ttry {\r\n\t\t\tconst childWorker = await createWorker(\"/workers/childworker.js\");\r\n\t\t\tchildWorker.addEventListener(\"message\", function (message) {\r\n\t\t\t\tlet response = message.data;\r\n\t\t\t\tpostMessage(response);\r\n\t\t\t});\r\n\t\t\tchildWorker.addEventListener(\"error\", (error) => {\r\n\t\t\t\tif (!error.message) {\r\n\t\t\t\t\tdispatchError(new Error(\"Network Error\", { cause: error.error }), message.data.id);\r\n\t\t\t\t\tchildWorker.terminate();                                                           //bad worker. Will never work.\r\n\t\t\t\t\tdelete workers[funcName];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdispatchError(new Error(error.message, { cause: error.error }), message.data.id);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tworkers[funcName] = childWorker;\r\n\t\t} catch (error) {\r\n\t\t\tdispatchError(error as Error);\r\n\t\t}\r\n\t\t//relay the message to the functions's worker for processing.\r\n\t}\r\n\t\tworkers[funcName].postMessage(message.data);\r\n}\r\n\r\nfunction dispatchError(error: Error, id: number | null = null) {                                                  //dispatches an error from a worker to its creator\r\n\tvar errorClone: { [prop: string]: any } = {}, errorProperties = Object.getOwnPropertyNames(error);\r\n\tfor (let i of errorProperties) {\r\n\t\terrorClone[i] = (error as any)[i];\r\n\t}\r\n\tpostMessage({ type: \"error\", errorClone, id });\r\n}","import { restorePrototype } from \"./utils\";\r\n\r\nexport function createWorker(source: string): Promise<Worker> {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tlet worker = new Worker(source);\r\n\t\tresolve(worker)\r\n\t})\r\n}\r\n\r\nlet mainWorker: Worker | null = null;\r\nconst mainWorkerCallbacks: {[id: number]: { resolve: (result: unknown) => void, reject: (err: any) => void }} = [];\r\n export async function runAsync(args: [...any], funcName: string): Promise<any> {           //runs a function asynchronously\r\n  let id = crypto.getRandomValues(new Uint32Array(new ArrayBuffer(4)))[0];\r\n  return new Promise(async (resolve: (value: unknown) => void, reject: (err: any) => void) => {\r\n    if (!mainWorker) {\r\n      try {\r\n      mainWorker = await createWorker(\"/workers/mainworker.js\");\r\n      mainWorker.onmessage = function (message) {\r\n        if (message.data._subworker) return;          //Do not process messages that are being relayed\r\n        let ext;\r\n        let messageId = message.data.id;\r\n        let callback = mainWorkerCallbacks[messageId];\r\n        if (message.data.type == \"error\") {\r\n          let error = message.data.error || Object.assign(new Error(), message.data.errorClone);\r\n          callback.reject(error);\r\n        } else if (message.data.type == \"answer\") {\r\n          let answer = message.data.answer;\r\n          restorePrototype(answer);\r\n          callback.resolve(answer);\r\n        }\r\n      };\r\n      mainWorker.onerror = error => {\r\n        let self = error.target;\r\n        if (!error.message) {\r\n          error = new ErrorEvent(\"Network Error\", {error: new Error(\"Network Error\")});\r\n        }\r\n        if (error.message.replace(/^.*Error:/, \"\").trim() === \"Network Error\" || error.error.message.replace(/^.*Error:/, \"\").trim() === \"Network Error\" ) {\r\n          self?.dispatchEvent(new MessageEvent(\"message\", { data: { type: \"error\", error: error.error, id } }));\r\n          mainWorker?.terminate();\r\n          mainWorker = null;                                                             //Destroy bad worker. It will never work.\r\n        } else {\r\n          self?.dispatchEvent(new MessageEvent(\"message\", { data: { type: \"error\", error: error.error, id } }))\r\n        }\r\n      };\r\n    } catch(err) {\r\n      mainWorker = null;\r\n      reject(err);\r\n      return;\r\n    }     \r\n }\r\n      mainWorkerCallbacks[id] = { resolve, reject };\r\n      solve(args, funcName, id);\r\n})\r\n}\r\nfunction solve(args: any, funcName: string, id: number) {\r\n  mainWorker?.postMessage({ args, funcName, id });\r\n}"],"names":["module","exports","isWorker","document","e","self","Worker","path","this","id","Math","random","toString","substr","eventListeners","error","addEventListener","data","_from","cmd","relayEvent","MessageEvent","initMessageEvent","message","dispatchEvent","onmessage","Object","assign","Event","errorProperties","onerror","bind","location","pathname","absPath","substring","lastIndexOf","postMessage","_subworker","prototype","terminate","type","listener","useCapture","push","removeEventListener","index","indexOf","splice","event","listeners","i","length","allWorkers","cmds","newWorker","workerId","worker","envelope","target","lineno","filename","colno","passMessage","messageRecieved","oldWorker","constructor","TypeError","blobIndex","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","workers","dispatchError","errorClone","getOwnPropertyNames","async","source","funcName","childWorker","Promise","resolve","reject","response","Error","cause"],"sourceRoot":""}