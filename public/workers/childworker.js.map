{"version":3,"file":"workers/childworker.js","mappings":"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","sources":["webpack://math-util/./src/scripts/utils.ts","webpack://math-util/webpack/bootstrap","webpack://math-util/webpack/runtime/define property getters","webpack://math-util/webpack/runtime/hasOwnProperty shorthand","webpack://math-util/webpack/runtime/make namespace object","webpack://math-util/./src/scripts/solvers/baseConverter.ts","webpack://math-util/./src/scripts/solvers/prime.ts","webpack://math-util/./src/scripts/workers/childWorker.ts","webpack://math-util/./src/scripts/solvers/quadratic.ts","webpack://math-util/./src/scripts/solvers/polynomial.ts"],"sourcesContent":["\r\n\r\nfunction restorePrototype(obj: any): any {\r\n\tif (typeof obj == \"object\") {\r\n\t\tif (obj.extension) obj.__proto__ = extensions[obj.extension].prototype;\r\n\t\tfor (let prop in obj) {\r\n\t\t\tlet val = obj[prop];\r\n\t\t\trestorePrototype(val);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction disableForm(form: HTMLFormElement) {\r\n\tArray.prototype.forEach.call(form.elements, e => {\r\n\t\te.disabled = e.readOnly = true;\r\n\t\tif (e.__proto__ === `HTMLButtonElementPrototype` || e.type === \"submit\") e.style.cursor = `wait`;\r\n\t});\r\n}\r\n\r\nfunction enableForm(form: HTMLFormElement) {\r\n\tArray.prototype.forEach.call(form.elements, e => {\r\n\t\te.disabled = e.readOnly = false;\r\n\t\tif (e.__proto__ === `HTMLButtonElementPrototype` || e.type === \"submit\") e.style.cursor = `default`;\r\n\t});\r\n}\r\n\r\n\r\nconst factorsCache: { [n: number]: number[], get length(): number } = {\r\n\tget length() {\r\n\t\treturn Object.keys(this).length;\r\n\t}\r\n};\r\nfunction factors(x: number): number[] { //returns all the positive integer factors of x, including x\r\n\tx = Math.abs(x);\r\n\tif (x in factorsCache) return factorsCache[x]; //if x has already been solved before, then return the value\r\n\tvar answer = [x],\r\n\t\tincrement = (x % 2 == 0 ? 1 : 2),\r\n\t\tbase = ((x % 2 == 0 ? 2 : 3)); //if x is an odd number, then check only the odd numbers. Otherwise check both odd & even no.s\r\n\tfor (var i = base; i <= Math.floor(Math.sqrt(x)); i += increment) {\r\n\t\tif (x % i == 0) {\r\n\t\t\t;\r\n\t\t\tvar right = factors(x / i),\r\n\t\t\t\tleft = factors(i); //when a factor of x is found, find it's complement, evaluate both their factors & combine them..\r\n\t\t\tanswer = [...answer, ...right, ...left]; //to get the complete factors. (This is because the factors of a number is the product of the..\r\n\t\t\tfor (var m = 0, n = right[m]; m < right.length; ++m, n = right[m]) { //combination of the factors of any of it's complementary factors.\r\n\t\t\t\tfor (var p = 0, q = left[p]; p < left.length; ++p, q = left[p]) {\r\n\t\t\t\t\tif (n * q !== x) answer.push(n * q);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tif (Set) { //remove all duplicate values in answer\r\n\t\t\t\tanswer = [...(new Set(answer))];\r\n\t\t\t} else {\r\n\t\t\t\tanswer = answer.reduce(function (list: number[], n) {\r\n\t\t\t\t\tif (list.every(function (s) {\r\n\t\t\t\t\t\treturn s !== n\r\n\t\t\t\t\t})) {\r\n\t\t\t\t\t\tlist.push(n);\r\n\t\t\t\t\t};\r\n\t\t\t\t\treturn list;\r\n\t\t\t\t}, []);\r\n\t\t\t}\r\n\t\t\tanswer = answer.sort(function (a, b) {\r\n\t\t\t\treturn a - b\r\n\t\t\t});\r\n\t\t\tfactorsCache[x] = answer;\r\n\t\t\treturn answer;\r\n\t\t}\r\n\t}\r\n\tfactorsCache[x] = answer;\r\n\treturn [x]\r\n}\r\n\r\nfunction isSquare(x: number) { //Returns a boolean indicating whether or not x is a perfect square\r\n\tconst sqr = Math.sqrt(x);\r\n\treturn sqr == Math.floor(sqr) ? true : false\r\n};\r\n\r\nfunction makeWhole(...numbers: number[]): { numbers: number[], decimalDigits: number } { //returns all of numbers as whole by multiplying through by 10^ highest number of decimal digits\r\n\tconst formattedNumbers: string[] = numbers.map(n => ~String(n).indexOf(\"e\") ? n.toFixed(15).replace(/0+$/, ``) : n.toString()); //collect all arguments in string form\r\n\t//determine the highest number of decimal digits in numbers\r\n\tlet highestDecimalDigits = formattedNumbers.every(Number.isInteger) ? 0 : formattedNumbers.reduce((h, n) => Math.max(h, (~n.indexOf(\".\")) ? (n.length - 1) - n.indexOf(\".\") : 0), 0);\r\n\treturn { decimalDigits: highestDecimalDigits, numbers: formattedNumbers.map(n => Math.round(Number(n) * Math.pow(10, highestDecimalDigits))) } //multiply all of the numbers by 10^ the highest decimal digits count\r\n};\r\n\r\nfunction sqRoot(n: number /*number*/) { //Returns the square root of n. returns a surd or a complex number where applicable\r\n\tvar nP = Math.abs(n); //set nP to the positive value of n\r\n\tlet result: string | number = \"\\u221A\" + n; //set result to root n, if n isn't a perfect square and neither is any of it's factors.\r\n\tif (isSquare(nP)) {\r\n\t\tresult = (n >= 0) ? Math.sqrt(nP) : Math.sqrt(nP) + \"\\u221A\" + -1; //if nP is a perfect square, set result to root n if n was positive else, set to root n * root -1\r\n\t} else {\r\n\t\tfor (var nP_fcList = factors(nP), i = nP_fcList.length - 1, j = nP_fcList[i]; i > -1; --i, j = nP_fcList[i]) { //Take the highest perfect square factor of xP if any,..\r\n\t\t\tif (isSquare(j)) {\r\n\t\t\t\tresult = Math.sqrt(j) + \"\\u221A\" + n / j;\r\n\t\t\t\tbreak; //..factor it out and multiply it's root by what is left under the square root sign.\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn result\r\n}\r\n\r\nfunction lowestRatios(...numbers: number[]) { //returns the lowest integer ratios of all the numbers\r\n\tvar answer = makeWhole(...numbers),\r\n\t\tlowest = Math.min(...answer.numbers),\r\n\t\tfctList = factors(lowest); //select the lowest number in the arguments and find its factors\r\n\tfor (var i = fctList.length - 1, j = fctList[i]; i >= 0; --i, j = fctList[i]) {\r\n\t\tif (answer.numbers.every(isFactorOf.bind(null, j))) { //if all other arguments are divisible by any of the factors, highest to lowest,..\r\n\t\t\treturn answer.numbers.map(divide.bind(null, j)); //then divide them through by the factor and return\r\n\t\t}\r\n\t}\r\n\treturn answer.numbers; //if none of the factors could divide through, then return the original arguments\r\n}\r\n\r\n\r\nfunction isFactorOf(x: number, n: number) {\r\n\treturn n % x == 0;\r\n}\r\n\r\nfunction divide(x: number, n: number) {\r\n\treturn n / x;\r\n}\r\n\r\n\r\nfunction combination(n: number, m: number) {\r\n\treturn factorial(n) / (factorial(n - m) * factorial(m));\r\n}\r\n\r\nfunction factorial(n: number) {\r\n\tlet count = n,\r\n\t\tans = 1;\r\n\twhile (count > 0) {\r\n\t\tans *= count;\r\n\t\t--count;\r\n\t}\r\n\treturn ans;\r\n}\r\n\r\n//class definitions\r\n/*\r\n * instances \"extension\" property are used to restore their prototype when they are transferred to/from workers.\r\n */\r\nclass Fraction {\r\n\textension = \"Fraction\";\r\n\tnume: number | string;\r\n\tdenom: number | string\r\n\tconstructor(nume: number | string, denom: number | string) {\r\n\t\tif (arguments.length == 2) {\r\n\t\t\t//if one argument is supplied, then represent it as a fraction, otherwise, make a fraction from two arguments supplied.\r\n\t\t\tthis.nume = nume;\r\n\t\t\tthis.denom = denom;\r\n\t\t} else {\r\n\t\t\tif (typeof nume == \"number\") {\r\n\t\t\t\tlet whole = makeWhole(nume);\r\n\t\t\t\tthis.nume = whole.numbers[0];\r\n\t\t\t\tthis.denom = Math.pow(10, whole.decimalDigits);\r\n\t\t\t} else {\r\n\t\t\t\tthis.nume = nume;\r\n\t\t\t\tthis.denom = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ttoLowestTerms() { //returns the fraction in it's lowest terms.\r\n\t\tlet t, d, top, bottom, reducedRatios, n = String(this.nume),\r\n\t\t\tdenom = String(this.denom);\r\n\t\tif (!isNaN(t = parseFloat(n)) && !isNaN(d = parseFloat(denom))) {\r\n\t\t\treducedRatios = lowestRatios(t, d);\r\n\t\t\ttop = reducedRatios[0];\r\n\t\t\tbottom = reducedRatios[1]\r\n\t\t\tif (bottom < 0) bottom = -bottom, top = -top; //make the denominator positive\r\n\t\t\tn = n.replace(t.toString(), top.toString()); //replace the coefficients\r\n\t\t\tdenom = denom.replace(d.toString(), bottom.toString());\r\n\t\t} else {\r\n\t\t\tif (denom[0] == \"-\") denom = denom.replace(/^-/, \"\"), n = n[0] == \"-\" ? n.replace(/^-/, \"\") : \"-\" + n;\r\n\t\t}\r\n\t\treturn new Fraction(n, denom);\r\n\t}\r\n\tvalueOf() {\r\n\t\treturn Number(this.nume) / Number(this.denom)\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\nclass Term {\r\n\textension = \"Term\";\r\n\tcoefficient: number = 1;\r\n\tvariables: Exponential[];\r\n\tconstructor(...args: Exponential[]) {\r\n\t\tfor (let index = 0; index < args.length; index++) {\r\n\t\t\tif (!isNaN(Number(args[index]))) {\r\n\t\t\t\tthis.coefficient *= Number(args[index]);\r\n\t\t\t\targs.splice(index--, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.variables = args.reduce((product: Exponential[], arg) => {\r\n\t\t\tfor (let i = 0, processedArg: Exponential; i < product.length; i++) {\r\n\t\t\t\tprocessedArg = product[i];\r\n\t\t\t\tif (processedArg.compareBase(arg) == 0) {   //if the variable has equivalent base as arg, add arg's power to it\r\n\t\t\t\t\tproduct[i] = new Exponential(processedArg.base, add(product[i].power, arg.power));\r\n\t\t\t\t\treturn product;\r\n\t\t\t\t} else if (typeof (arg.base) == \"string\" && typeof (processedArg.base) == \"string\")\r\n\t\t\t\t\tfor (let processedvariable of processedArg.base) {\r\n\t\t\t\t\t\tfor (let argvariable of arg.base as string) {\r\n\t\t\t\t\t\t\tif (argvariable == processedvariable) {                               //if a single letter of arg is in productvariable\r\n\t\t\t\t\t\t\t\tlet toAdd;\r\n\t\t\t\t\t\t\t\ttoAdd = new Exponential(processedvariable, add(processedArg.power, arg.power));\r\n\t\t\t\t\t\t\t\tprocessedArg = product[i] = new Exponential((processedArg.base as string).replace(processedvariable, \"\"), processedArg.power);\r\n\t\t\t\t\t\t\t\tif (!(product[i].base)) product.splice(i--, 1);\r\n\t\t\t\t\t\t\t\targ = new Exponential((arg.base as string).replace(processedvariable, \"\"), arg.power);\r\n\t\t\t\t\t\t\t\tif (product.length) {\r\n\t\t\t\t\t\t\t\t\tfor (let already in product) {\r\n\t\t\t\t\t\t\t\t\t\tif (product[already].comparePower(toAdd) == 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (isString(toAdd.base) && isString(product[already].base)) product[already] = new Exponential((product[already].base as string) + toAdd.base, product[already].power);\r\n\t\t\t\t\t\telse product[already] = new Exponential(multiply(product[already].base, toAdd.base), product[already].power);\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t} else if (Number(already) == product.length - 1) {\r\n\t\t\t\t\t\t\t\t\t\t\tproduct.push(toAdd);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tproduct.push(toAdd);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (Number(arg) == 0) return product; //arg's base may have been exhausted\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\tif (product[i]) {\r\n\t\t\t\t\tif (product[i].comparePower(arg) == 0) {\r\n\t\t\t\t\t\tif (isString(arg.base) && isString(product[i].base)) product[i] = new Exponential((product[i].base as string) + arg.base, product[i].power);\r\n\t\t\t\t\t\telse product[i] = new Exponential(multiply(product[i].base, arg.base), product[i].power);\r\n\t\t\t\t\t\treturn product;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (arg.base) product.push(arg);\r\n\r\n\t\t\treturn product;\r\n\t\t}, []);\r\n\t\tthis.variables.sort((a, b) => {\r\n\t\t\tif (isString(a.base)) {\r\n\t\t\t\tif (isString(b.base)) return (a.base as string).localeCompare(b.base as string);        //arrange variables in aphabetical order\r\n\t\t\t\telse return -1;      //complex term should come last\r\n\t\t\t} else {\r\n\t\t\t\tif (isString(b.base)) return 1;\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\tvalueOf() {\r\n\t\tif (this.coefficient == 0) return 0;\r\n\t\treturn this.variables.reduce((a, b) => Number(a) * Number(b), this.coefficient)\r\n\t}\r\n\r\n\tisAddable(other: Term) {\r\n\t\tif (this.variables.length != other.variables.length) return false;\r\n\t\touterLoop: for (let thisVariable of this.variables) {\r\n\t\t\tfor (let otherVariable of other.variables) {\r\n\t\t\t\tif (thisVariable.comparePower(otherVariable) != 0) continue;  //variables do not match\r\n\t\t\t\tif (thisVariable.compareBase(otherVariable) == 0) continue outerLoop; //both base and power match\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tflatten() {\r\n\t\tconst flattenedVariables = this.variables.map(variable => variable.flatten());\r\n\t\treturn flattenedVariables.reduce(\r\n\t\t\t(cumulativeProduct, pol) => multiply(cumulativeProduct, pol),\r\n\t\t\tnew Polynomial(this.coefficient));\r\n\t}\r\n\r\n}\r\n\r\n\r\nfunction isString(str: any) { return typeof (str) == \"string\" || str instanceof String; }\r\n\r\nclass Tree<T> {\r\n\tcargo: T;\r\n\tleft: Tree<T> | null;\r\n\tright: Tree<T> | null;\r\n\r\n\tconstructor(cargo: T, left: Tree<T> | null = null, right: Tree<T> | null = null) {\r\n\t\t[this.cargo, this.left, this.right] = [cargo, left, right]\r\n\t}\r\n\ttoString() {\r\n\t\tfunction _toFormat(tree: Tree<T>, width: number, height: number, offset: number) {\r\n\t\t\toffset += width;\r\n\t\t\tlet str = \"\";\r\n\t\t\tif (tree.isLeaf) return str + \" \".repeat(offset) + String(tree.cargo) + \"\\n\".repeat(height);\r\n\t\t\telse if (!(tree.left && tree.right)) throw new Error(\"not a tree\");\r\n\t\t\tstr += _toFormat(tree.left, width, height, offset);\r\n\t\t\tstr += \" \".repeat(offset) + String(tree.cargo) + \"\\n\".repeat(height);\r\n\t\t\tstr += _toFormat(tree.right, width, height, offset);\r\n\t\t\treturn str;\r\n\t\t}\r\n\t\treturn _toFormat(this, 8, 1, -8)\r\n\t}\r\n\r\n\tget isLeaf() {\r\n\t\treturn this.left == null && this.right == null ? true : false;\r\n\t}\r\n\treplaceNode(node: Tree<T>, newNode: Tree<T>) {\r\n\t\tlet currentTreeNode: Tree<T> = this;\r\n\t\twhile (currentTreeNode.right) {\r\n\t\t\tif (currentTreeNode.right == node) {\r\n\t\t\t\tcurrentTreeNode.right = newNode;\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tcurrentTreeNode = currentTreeNode.right;\r\n\t\t}\r\n\t}\r\n\r\n\tgetRightMost() {\r\n\t\tlet rightMost: Tree<T> = this;\r\n\t\twhile (rightMost.right instanceof Tree) rightMost = rightMost.right;\r\n\t\treturn rightMost;\r\n\t}\r\n\r\n\textend(value: T) {\r\n\t\tlet previousValue = this.cargo;\r\n\t\tthis.cargo = value;\r\n\t\tthis.left = new Tree(previousValue, this.left, this.right);\r\n\t\tthis.right = null;\r\n\t}\r\n\r\n\tprint(indent: number) {\r\n\t\tconsole.log('  '.repeat(indent) + (this.cargo as Object).toString());\r\n\t\tif (this.left) this.left.print(indent + 5);\r\n\t\tif (this.right) this.right.print(indent + 5);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nclass Polynomial {\r\n\tterms: Term[] = [];\r\n\tvariableLetters: Set<string> = new Set;\r\n\textension: string = \"Polynomial\";\r\n\r\n\tconstructor(terms: Term[] | Term | number | string = []) {\r\n\t\tif (typeof terms == \"number\" || typeof terms == \"string\") terms = [new Term(new Exponential(terms))];\r\n\t\telse if (terms instanceof Term) terms = [terms];\r\n\t\tprocessTerms: for (let term of terms) {\r\n\t\t\tif (Number(term) == 0) continue;\r\n\t\t\tfor (let variable of term.variables) {\r\n\t\t\t\tif (variable.base instanceof Polynomial) variable.base.variableLetters.forEach(letter => this.variableLetters.add(letter));\r\n\t\t\t\telse if (typeof variable.base == \"string\") this.variableLetters = new Set([...this.variableLetters, ...variable.base.split(\"\")]);\r\n\t\t\t\tif (variable.power instanceof Polynomial) variable.power.variableLetters.forEach(letter => this.variableLetters.add(letter));\r\n\t\t\t\telse if (typeof variable.power == \"string\") this.variableLetters = new Set([...this.variableLetters, ...variable.power.split(\"\")]);\r\n\t\t\t}\r\n\t\t\tfor (let index = 0, processedTerm: Term; index < this.terms.length; index++) {\r\n\t\t\t\tprocessedTerm = this.terms[index];\r\n\t\t\t\tif (processedTerm.isAddable(term)) {\r\n\t\t\t\t\tprocessedTerm.coefficient += term.coefficient;\r\n\t\t\t\t\tif (processedTerm.coefficient == 0) {\r\n\t\t\t\t\t\tthis.terms.splice(index--, 1);    //in case adding produced 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue processTerms;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.terms.push(term);\r\n\t\t}\r\n\t}\r\n\r\n\tvalueOf() {\r\n\t\treturn this.terms.reduce((sum, term) => sum + Number(term), 0)\r\n\t}\r\n\r\n\tlocaleCompare(other: Polynomial | number | string) {\r\n\t\tif (typeof other == \"string\") other = new Polynomial(other);\r\n\t\telse if (typeof other == \"number\") other = new Polynomial(other);\r\n\t\tif (this.terms.length != other.terms.length) return NaN;\r\n\t\tconst [thisTerms, otherTerms] = [this.flatten().terms, other.flatten().terms]\r\n\t\touterLoop: for (const thisTerm of thisTerms) {\r\n\t\t\tfor (let index = 0; index < otherTerms.length; index++) {\r\n\t\t\t\tconst otherTerm = otherTerms[index];\r\n\t\t\t\tif (thisTerm.coefficient == otherTerm.coefficient && thisTerm.isAddable(otherTerm)) {\r\n\t\t\t\t\totherTerms.splice(index--, 1);\r\n\t\t\t\t\tcontinue outerLoop;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\t\tif (otherTerms.length) return NaN;\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\tadd(term: Term) {\r\n\t\tif (Number(term) != 0) {\r\n\t\t\tfor (let variable of term.variables) {\r\n\t\t\t\tif (variable.base instanceof Polynomial) variable.base.variableLetters.forEach(letter => this.variableLetters.add(letter));\r\n\t\t\t\telse this.variableLetters = new Set([...this.variableLetters, ...(typeof variable.base == \"string\" ? variable.base.split(\"\") : \"\")]);\r\n\t\t\t\tif (variable.power instanceof Polynomial) variable.power.variableLetters.forEach(letter => this.variableLetters.add(letter));\r\n\t\t\t\telse this.variableLetters = new Set([...this.variableLetters, ...(typeof variable.power == \"string\" ? variable.power.split(\"\") : \"\")]);\r\n\r\n\t\t\t}\r\n\t\t\tfor (let index = 0, processedTerm; index < this.terms.length; index++) {\r\n\t\t\t\tprocessedTerm = this.terms[index];\r\n\t\t\t\tif (processedTerm.isAddable(term)) {\r\n\t\t\t\t\tconst coefficient = processedTerm.coefficient += term.coefficient;\r\n\t\t\t\t\tif (coefficient == 0) {\r\n\t\t\t\t\t\tthis.terms.splice(index--, 1);    //in case adding produced 0\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.terms.push(term);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tflatten() {\r\n\t\tif (this.terms.length == 0) return this;\r\n\t\tconst allTerms = [...this.terms.map(term => term.flatten().terms).reduce((termsa, termsb) => termsa.concat(termsb))]\r\n\t\treturn new Polynomial(allTerms);\r\n\t}\r\n\r\n\tget multivariable() {\r\n\t\treturn this.variableLetters.size > 1;\r\n\t}\r\n\tget degree() {\r\n\t\tlet degree = 0;\r\n\t\tfor (const term of this.terms) {\r\n\t\t\tfor (const variable of term.variables) {\r\n\t\t\t\tdegree = Math.max(degree, Number(variable.power));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn degree;\r\n\t}\r\n\tget length() {\r\n\t\treturn this.terms.length\r\n\t}\r\n}\r\n\r\nclass Exponential {\r\n\tpower: Polynomial | string | number;\r\n\tbase: Polynomial | string | number;\r\n\textension: string = \"Exponential\";\r\n\tconstructor(base: Polynomial | string | number);\r\n\tconstructor(base: Polynomial | string | number, power: Polynomial | string | number);\r\n\tconstructor(base: Polynomial | string | number, power: Polynomial | string | number = 1) {\r\n\t\tif (typeof base == \"number\" || !isNaN(Number(base))) this.base = Number(base); //if it can be converted to a number, then do so\r\n\t\telse if (typeof (base) == \"string\" || base instanceof String) this.base = base.split(\"\").sort().join(\"\");  //if it is a string, then sort it\r\n\t\telse {\r\n\t\t\t// if (base.terms.length == 1) { //if it has just one term, raise the power of the variables in the term\r\n\t\t\t// \tlet product = new Polynomial();\r\n\t\t\t// \tlet variables: Exponential[] = [];\r\n\t\t\t// \tfor (let variable of base.terms[0].variables) {\r\n\t\t\t// \t\tvariables.push(new Exponential(variable.base, multiply(variable.power, power))\r\n\t\t\t// \t\t);\r\n\t\t\t// \t}\r\n\t\t\t// \tif (!isNaN(Number(power))) variables.push(new Exponential(base.terms[0].coefficient ** Number(power)));\r\n\t\t\t// \telse variables.push(new Exponential(base.terms[0].coefficient, power));\r\n\t\t\t// \tproduct.add(new Term(...variables));\r\n\t\t\t// \tthis.base = product;\r\n\t\t\t// \tpower = 1;\r\n\t\t\t// } else \r\n\t\t\tthis.base = base; //otherwise, leave as is. Will require expansion \r\n\t\t}\r\n\t\tif (!isNaN(Number(power))) this.power = Number(power);\r\n\t\telse if (typeof power == \"string\" || power instanceof String) this.power = power.split(\"\").sort().join(\"\");\r\n\t\telse this.power = power;\r\n\t}\r\n\tvalueOf() {\r\n\t\tif (Number(this.base) == 1) return 1;\r\n\t\tif (Number(this.base) == 0) return 0;\r\n\t\treturn Math.pow(Number(this.base), Number(this.power.valueOf()));\r\n\t}\r\n\tcomparePower(other: Exponential) {\r\n\t\treturn this.compareComponents(this.power, other.power);\r\n\t}\r\n\tcompareComponents(a: Polynomial | string | number, b: Polynomial | string | number) {\r\n\t\tif (a.valueOf() == b.valueOf()) return 0;\r\n\t\tif (typeof a == \"string\" || a instanceof String) {\r\n\t\t\tif ((typeof b == \"string\" || b instanceof String) && a.localeCompare(b as string) == 0) return 0;\r\n\t\t\tif (b instanceof Polynomial && new Polynomial(new Term(new Exponential(a))).localeCompare(b) == 0) return 0;\r\n\t\t} else if (a instanceof Polynomial) {\r\n\t\t\tif (b instanceof Polynomial && a.localeCompare(b) == 0) return 0;\r\n\t\t\tif ((typeof b == \"string\" || b instanceof String) && new Polynomial(new Term(new Exponential(b))).localeCompare(a) == 0) return 0;\r\n\t\t}\r\n\t\treturn NaN\r\n\t}\r\n\tcompareBase(other: Exponential): number {\r\n\t\treturn this.compareComponents(this.base, other.base);\r\n\t}\r\n\tflatten(): Polynomial {\r\n\t\tif (!isNaN(Number(this))) return new Polynomial(Number(this));  //if they are both number\r\n\t\tif (!isNaN(Number(this.power)) && Number(this.power) >= 0) {\r\n\t\t\tif (this.base instanceof Polynomial) {\r\n\t\t\t\tconst flattenedBase = this.base.flatten();\r\n\t\t\t\tlet power: number = Number(this.power);\r\n\t\t\t\tlet cumulativeProduct = flattenedBase;\r\n\t\t\t\twhile (power > 1) {\r\n\t\t\t\t\tconst newCumulative = new Polynomial();\r\n\t\t\t\t\tfor (const terma of flattenedBase.terms) {\r\n\t\t\t\t\t\tfor (const termb of cumulativeProduct.terms) {\r\n\t\t\t\t\t\t\tmultiply(new Polynomial(terma), new Polynomial(termb)).terms.forEach(term => newCumulative.add(term));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcumulativeProduct = newCumulative;\r\n\t\t\t\t\tpower--;\r\n\t\t\t\t}\r\n\t\t\t\treturn cumulativeProduct;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tlet simplifiedBase = this.base;\r\n\t\tlet simplifiedPower = this.power;\r\n\t\tif (simplifiedBase instanceof Polynomial) {\r\n\t\t\tlet flattenedBase: string | Polynomial | number = simplifiedBase.flatten();\r\n\t\t\tif (flattenedBase.terms.length == 1 && flattenedBase.terms[0].coefficient == 1 && flattenedBase.terms[0].variables.length == 1 && flattenedBase.terms[0].variables[0].power == 1) flattenedBase = flattenedBase.terms[0].variables[0].base;\r\n\t\t\tsimplifiedBase = flattenedBase;\r\n\t\t}\r\n\t\tif (simplifiedPower instanceof Polynomial) {\r\n\t\t\tlet flattenedPower: string | Polynomial | number = simplifiedPower.flatten();\r\n\t\t\tif (flattenedPower.terms.length == 1 && flattenedPower.terms[0].coefficient == 1 && flattenedPower.terms[0].variables.length == 1 && flattenedPower.terms[0].variables[0].power == 1) flattenedPower = flattenedPower.terms[0].variables[0].base;\r\n\t\t\tsimplifiedPower = flattenedPower;\r\n\t\t}\r\n\t\treturn new Polynomial(new Term(new Exponential(simplifiedBase, simplifiedPower)));\r\n\t}\r\n}\r\n\r\nfunction tokenize(expr: string) {\r\n\texpr = expr.replace(/[\\s\\n\\t]+/g, \"\")\r\n\tlet result;\r\n\tlet tokens: string[] = [];\r\n\tlet lastIndex = 0;\r\n\tlet numberMatcher = /(\\d*\\.\\d+)|\\d+/g;\r\n\twhile (result = numberMatcher.exec(expr)) {\r\n\t\ttokens = tokens.concat(expr.slice(lastIndex, result.index).split(\"\"));\r\n\t\ttokens.push(result[0]);\r\n\t\tlastIndex = numberMatcher.lastIndex;\r\n\t}\r\n\ttokens = tokens.concat(expr.slice(lastIndex, expr.length).split(\"\"));;\r\n\ttokens.push(\"end\");\r\n\treturn tokens\r\n}\r\nfunction getToken(token: RegExp, tokens: string[]) {\r\n\tif (token.test(tokens[0])) {\r\n\t\treturn tokens.shift();\r\n\t}\r\n\treturn null\r\n}\r\n\r\nfunction peekToken(token: RegExp, tokens: string[]) {\r\n\treturn token.test(tokens[0])\r\n}\r\n\r\nfunction getSingleTerm(tokens: string[]) {\r\n\tlet coefficient = 1;\r\n\tlet value: string | number | null = null;\r\n\tlet variable, number, sign;\r\n\twhile (sign = getToken(/^[-+]$/, tokens)) {\r\n\t\tcoefficient *= Number(sign[0] + 1);\r\n\t}\r\n\tif (coefficient == -1 && peekToken(/^\\(/, tokens)) value = \"1\"; //a minus sign being before an opening paranthesis implies multiplication by -1\r\n\telse if (variable = getToken(/^[a-zA-Z]/, tokens)) value = variable;\r\n\telse if (number = getToken(/^(\\d*\\.\\d+)|\\d+/, tokens)) value = Number(0 + number);\r\n\tif (coefficient == 1 && value != null) value = \"+\" + value;\r\n\telse if (value != null) value = \"-\" + value;\r\n\treturn value\r\n}\r\nfunction getOperator(tokens: string[]) {\r\n\tlet token = getToken(/^[\\+\\-\\*\\/\\^]/, tokens);\r\n\tif (token) return token;\r\n\tif (peekToken(/^[a-zA-Z]/, tokens)) return \"*\"; //a digit/variable being before a variable implies multiplication\r\n\tif (peekToken(/^\\(/, tokens)) return \"*\"; //a digit/variable being before an opening paranthesis implies multiplication\r\n\treturn null;\r\n}\r\n\r\nfunction getLParans(tokens: string[]) {\r\n\tlet token = getToken(/^\\(/, tokens);\r\n\tif (token) return token;\r\n\treturn null;\r\n}\r\n\r\nfunction getRParans(tokens: string[]) {\r\n\tlet token = getToken(/\\)/, tokens);\r\n\tif (token) return token;\r\n\treturn null;\r\n}\r\n\r\nfunction getRank(operator: string) {\r\n\tif (/^[\\^]$/.test(operator)) return 1;\r\n\tif (/^[\\/\\*]$/.test(operator)) return 2;\r\n\tif (/^[\\+\\-]$/.test(operator)) return 3;\r\n\r\n}\r\n\r\nfunction getAllTerms(tokens: string[]): Tree<string | number> {\r\n\tlet rootNode: Tree<string | number> | null = null;\r\n\tlet currentNode: Tree<string | number> | null = null;\r\n\tlet rightmostNode: Tree<string | number> | null = null;\r\n\tlet parenthesisIndices: ({ main: Tree<string | number>, rightmostNode: Tree<string | number> } | null)[] = [];\r\n\tlet last: \"operator\" | \"term\" = \"operator\";\r\n\tlet term: Tree<string | number>;\r\n\tlet operator: string;\r\n\r\n\twhile (!getToken(/^end$/, tokens)) {\r\n\t\tif (getRParans(tokens)) {\r\n\t\t\tif (!parenthesisIndices.length) throw new SyntaxError(`Unexpected closing bracket: No matching opening bracket was found`);\r\n\t\t\tif (last == \"operator\") throw new SyntaxError(`Unexpected closing bracket: value or expression expected`);\r\n\t\t\tconst topNode = parenthesisIndices.pop();\r\n\t\t\trightmostNode = currentNode;\r\n\t\t\tif (topNode != null) {\r\n\t\t\t\ttopNode.rightmostNode.right = rightmostNode;\r\n\t\t\t\tcurrentNode = topNode.main;\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tswitch (last) {\r\n\t\t\tcase \"operator\":     //Assume the rightmost leaf is null\r\n\t\t\t\tconst term = getSingleTerm(tokens);\r\n\t\t\t\tif (term) {\r\n\t\t\t\t\tlast = \"term\";\r\n\t\t\t\t\tif (rootNode == null) rootNode = currentNode = rightmostNode = new Tree(term);\r\n\t\t\t\t\telse if (rightmostNode == null) currentNode = rightmostNode = new Tree(term);\r\n\t\t\t\t\telse rightmostNode = rightmostNode.right = new Tree(term);\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tif (getLParans(tokens)) {\r\n\t\t\t\t\tparenthesisIndices.push(currentNode && rightmostNode ? { main: currentNode, rightmostNode } : null);\r\n\t\t\t\t\tcurrentNode = rightmostNode = null;\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tif (peekToken(/end/, tokens)) {\r\n\t\t\t\t\tlast = \"operator\";\t//might have removed some + or -\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new SyntaxError(`unexpected token '${tokens.shift()}': value or expression expected.`);\r\n\t\t\tcase \"term\":\r\n\t\t\t\tconst operator = getOperator(tokens)\r\n\t\t\t\tif (operator) {\r\n\t\t\t\t\tif (!rightmostNode) rightmostNode = currentNode;\r\n\t\t\t\t\tlast = \"operator\";\r\n\t\t\t\t\tswitch (getRank(operator)) {\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\tif (rightmostNode) rightmostNode.extend(operator);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\tcurrentNode.extend(operator);\r\n\t\t\t\t\t\t\t\trightmostNode = currentNode;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new SyntaxError(`unexpected token '${tokens.shift()}': operator expected.`);\r\n\t\t}\r\n\t}\r\n\tif (parenthesisIndices.length) throw new SyntaxError(`unexpected end of input : ${last == \"operator\" ? \"value or expression\" : \"operator/closing bracket\"} expected.`);\r\n\tif (last == \"operator\" || rootNode == null) throw new SyntaxError(\"unxpected end of input: value or expression expected\");\r\n\treturn rootNode\r\n}\r\n\r\nfunction add(a: Polynomial | string | number, b: Polynomial | string | number) {\r\n\tlet sum = new Polynomial();\r\n\tif (!isNaN(Number(a)) && !isNaN(Number(b))) {\r\n\t\tsum.add(new Term(new Exponential(Number(a) + Number(b))));\r\n\t\treturn sum\r\n\t}\r\n\tif (!(a instanceof (Polynomial))) a = new Polynomial(new Term(new Exponential(a)));\r\n\tif (!(b instanceof (Polynomial))) b = new Polynomial(new Term(new Exponential(b)));\r\n\tfor (let operand of [a, b]) {\r\n\t\tfor (let term of operand.terms)\r\n\t\t\tsum.add(term);\r\n\t}\r\n\treturn sum;\r\n}\r\n\r\nfunction multiply(a: Polynomial | string | number, b: Polynomial | string | number) {\r\n\tif (!(b instanceof Polynomial)) b = new Polynomial(b);\r\n\tif (!(a instanceof Polynomial)) a = new Polynomial(a);\r\n\tlet product = new Polynomial();\r\n\tfor (let bTerm of b.terms) {\r\n\t\tfor (let aTerm of a.terms)\r\n\t\t\tproduct.add(new Term(...aTerm.variables, new Exponential(aTerm.coefficient), ...bTerm.variables, new Exponential(bTerm.coefficient)));\r\n\t}\r\n\treturn product;\r\n}\r\n\r\nfunction subtract(a: Polynomial | string | number, b: Polynomial | string | number) {\r\n\tlet sum = new Polynomial();\r\n\tif (!isNaN(Number(a)) && !isNaN(Number(b))) {\r\n\t\tsum.add(new Term(new Exponential(Number(a) - Number(b))));\r\n\t\treturn sum\r\n\t}\r\n\tif (!(a instanceof (Polynomial))) a = new Polynomial(new Term(new Exponential(a)));\r\n\tif (!(b instanceof (Polynomial))) b = new Polynomial(new Term(new Exponential(b)));\r\n\tfor (const term of a.terms) sum.add(term);\r\n\tfor (let term of b.terms) {\r\n\t\tconst negativeTerm = new Term(new Exponential(-term.coefficient), ...term.variables);\r\n\t\tsum.add(negativeTerm);\r\n\t}\r\n\treturn sum;\r\n}\r\n\r\nfunction raiseToPower(a: Polynomial, b: Polynomial) {\r\n\treturn new Polynomial(new Term(new Exponential(a, b)));\r\n}\r\n\r\nfunction parse(expression: string) {\r\n\tlet tree = getAllTerms(tokenize(expression));\r\n\treturn evaluate(tree);\r\n}\r\nfunction evaluate(tree: Tree<string | number>): Polynomial {\r\n\tif (tree.isLeaf) {\r\n\t\tlet coefficient = (tree.cargo as string)[0] == \"+\" ? 1 : -1;  //if the value has positive or negative sign in front\r\n\t\treturn new Polynomial(new Term(new Exponential(coefficient), new Exponential((tree.cargo as string).substring(1))));\r\n\t} else if (tree.left && tree.right) {\r\n\t\tlet left = evaluate(tree.left);\r\n\t\tlet right = evaluate(tree.right);\r\n\t\tswitch (tree.cargo) {\r\n\t\t\tcase \"*\": return multiply(left, right);\r\n\t\t\tcase \"+\": return add(left, right);\r\n\t\t\tcase \"^\": return raiseToPower(left, right);\r\n\t\t\tcase \"-\": return subtract(left, right);\r\n\t\t}\r\n\t}\r\n\tthrow new TypeError(\"cannot evaluate invalid expression tree\")\r\n}\r\n\r\nconst extensions: { [className: string]: new (...args: any) => any } = {\r\n\t\"Fraction\": Fraction,\r\n\t\"Term\": Term,\r\n\t\"Exponential\": Exponential,\r\n\t\"Polynomial\": Polynomial\r\n}\r\n\r\n\r\nexport {\r\n\tenableForm,\r\n\tdisableForm,\r\n\tfactors,\r\n\tisSquare,\r\n\tmakeWhole,\r\n\tsqRoot,\r\n\tlowestRatios,\r\n\tisFactorOf,\r\n\tmultiply,\r\n\tdivide,\r\n\tcombination,\r\n\tfactorial,\r\n\tFraction,\r\n\tTerm,\r\n\trestorePrototype,\r\n\tparse,\r\n\tgetAllTerms,\r\n\ttokenize,\r\n\tExponential,\r\n\tPolynomial,\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const utils = require(\"../utils\")\r\nexport function convertToBase(number: string, base: number, newBase: number) {\r\n\tlet value;\r\n\tnumber = number.toString().toLowerCase();\r\n\r\n\t//Defensive Assertions\r\n\tif (!(/\\b\\w+\\b/.test(number + base + newBase))) throw new Error(\"Invalid Input\")\r\n\tif (base > 36 || newBase > 36) throw new Error(\"Conversions Above Base 36 Not Supported!\");\r\n\tif (base < 2 || newBase < 2) throw new Error(\"Conversions Below Base 2 Not Supported!\");\r\n\tfor (var i = 0; i < number.length; ++i) { //check if digits in number is within the base range\r\n\t\tif (number.charCodeAt(i) < 58) {\r\n\t\t\tif (Number(base) + 48 <= number.charCodeAt(i)) throw new Error(`${number} Is Not A Base ${base} Number`);\r\n\t\t} else {\r\n\t\t\tif (number.charCodeAt(i) - 87 >= base) throw new Error(`${number} Is Not A Base ${base} Number`);\r\n\t\t}\r\n\t}\r\n\t//MAIN\r\n\r\n\tlet answer = base10ToBaseN(toBase10(number, base), newBase); //convert number to base10, then convert to new base\r\n\treturn answer\r\n\t//HELPER FUNCTIONS\r\n\r\n\tfunction toBase10(number: string | number, base: number) { //converts number to base10# \r\n\t\t\tnumber = number.toString();\r\n\t\tvar wholeResult = 0,\r\n\t\t\tfloatResult = 0,\r\n\t\t\tpointIndex = ~number.indexOf(\".\") ? number.indexOf(\".\") : Infinity;\r\n\t\tlet [whole, float] = [number.slice(0, pointIndex), number.slice(pointIndex + 1)];\r\n\t\tfor (let i = whole.length - 1, j = 0; i >= 0; --i, ++j) {\r\n\t\t\twholeResult += Math.pow(base, j) * (whole.charCodeAt(i) < 58 ? Number(whole[i]) : whole.charCodeAt(i) - 87);\r\n\t\t}\r\n\t\tif (!float) return wholeResult;\r\n\t\tfor (let placeValue: number, digit: number, i = 0, j = 1; i < float.length; ++i, ++j) {\r\n\t\t\tdigit = float.charCodeAt(i) < 58 ? Number(float[i]) : float.charCodeAt(i) - 87;\r\n\t\t\tplaceValue = Math.round(digit / Math.pow(base, j) * Math.pow(10, 15)) / Math.pow(10, 15);\r\n\t\t\tfloatResult = Math.round((floatResult + placeValue) * Math.pow(10, 15)) / Math.pow(10, 15);\r\n\t\t}\r\n\t\treturn Math.round((wholeResult + floatResult) * Math.pow(10, 15)) / Math.pow(10, 15);\r\n\t}\r\n\r\n\tfunction base10ToBaseN(number: number, n: number) { //Assumes number is in base10, converts it to baseN \r\n\t\tif (number > Number.MAX_SAFE_INTEGER) return number.toString(n);\r\n\t\tconst numberFixed = ~String(number).indexOf(\"e\") ? number.toFixed(15).replace(/0+$/, ``) : number.toString();\r\n\t\tlet floatResult, wholeResultDigits = [],\r\n\t\t\tpointIndex = ~numberFixed.indexOf(\".\") ? numberFixed.indexOf(\".\") : Infinity,\r\n\t\t\t[whole, float] = [Number(numberFixed.slice(0, pointIndex)), parseFloat(numberFixed.slice(pointIndex))],\r\n\t\t\tfraction = float ? (new utils.Fraction(float).toLowestTerms()) : null;\r\n\t\twhile (whole > 0) {\r\n\t\t\tlet digit = whole % n;\r\n\t\t\twholeResultDigits.push(digit < 10 ? whole % n : String.fromCharCode(digit + 87));\r\n\t\t\twhole = Math.floor(whole / n);\r\n\t\t}\r\n\t\tconst wholeResult = Number(wholeResultDigits.reverse().join(\"\")) || 0;\r\n\t\tif (fraction) {\r\n\t\t\t//[fraction.nume] = [base10ToBaseN(fraction.nume, n)];\r\n\t\t\tfloatResult = \".\";\r\n\t\t\tlet placeDigit, nume = fraction.nume;\r\n\t\t\tconst d = Number(fraction.denom);\r\n\t\t\twhile ((floatResult.length < 60) /*&& toBase10(wholeResult + ((floatResult+0)||\"\"),n)<Number(number)*/ ) {\r\n\t\t\t\t// nume += 0;\r\n\t\t\t\t// if(Number(toBase10(nume,n))<d){floatResult+=0; continue};\r\n\t\t\t\t// placeDigit = base10ToBaseN(Math.floor(toBase10(nume,n)/d),n);\r\n\t\t\t\t// nume = base10ToBaseN(Number((toBase10(nume,n) % d).toFixed(15)),n);\r\n\t\t\t\t// floatResult += placeDigit;\r\n\r\n\t\t\t\t// This method works too.\r\n\t\t\t\t// let product = Math.round(float * n * Math.pow(10,14))/Math.pow(10,14);\r\n\t\t\t\t// floatResult += base10ToBaseN(Math.floor(product),n);\r\n\t\t\t\t// float = String(product).replace(/^\\d+/,``)\r\n\r\n\t\t\t\tnume *= n;\r\n\t\t\t\tplaceDigit = Math.floor((nume) / d);\r\n\t\t\t\tfloatResult += base10ToBaseN(placeDigit, n)\r\n\t\t\t\tnume = nume % d;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (wholeResult + (floatResult || \"\")).replace(/(\\.\\w+?)0+$/g, \"$1\");\r\n\t}\r\n}\r\n","const primeCache: { [n: number]: number } = { 1: 2, 2: 3, 500000: 7368787, 1000000: 15485863 };\r\nexport function findPrime(x: number) {\r\n\t\tif (isNaN(x) || x < 1 || x > 100000000) throw new Error(\"Input Out Of Range\");\r\n\t\tif (x in primeCache) return primeCache[x];        //if the x prime has been calculated, return the cached answer\r\n\t\tvar count, number, x = Number(x), nearestIndex = Math.floor(x / 5000) * 5000;\r\n\t\tif (nearestIndex in primeCache) {\r\n\t\t\tcount = nearestIndex;\r\n\t\t} else {\r\n\t\t\tcount = Object.keys(primeCache)\r\n\t\t\t.map(x => Number(x))\r\n\t\t\t.reduce(function (least, num) { \r\n\t\t\t\tlet result;\r\n\t\t\t\tif (num < x && num > least) { least = num }; return least; }, 0)\r\n\t\t}\r\n\t\tnumber = primeCache[count];\r\n\t\twhile (count < x) {\r\n\t\t\tif (isPrime(number + 2)) {\r\n\t\t\t\t++count;\r\n\t\t\t\tif (count % 5000 === 0) primeCache[count] = number + 2;\r\n\t\t\t}\r\n\t\t\tnumber += 2;\r\n\t\t}\r\n\t\treturn number\r\n\t}\r\n\r\n\tfunction isPrime(x: number) {\r\n\t\tif (x == 2) return true;\r\n\t\tif (x == 1 || x % 2 == 0) return false;\r\n\t\tvar count = 3, limit = Math.sqrt(x) + 1;\r\n\t\twhile (count < limit) {\r\n\t\t\tif (x % count == 0) return false;\r\n\t\t\tcount += 2;\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n","import { convertToBase } from \"../solvers/baseConverter\";\r\nimport { findPrime } from \"../solvers/prime\";\r\nimport { quadraticRoots } from \"../solvers/quadratic\";\r\nimport { polynomialExpand } from \"../solvers/polynomial\";\r\nonmessage = function (message) {\r\n\tif (message.data._subworker) return;\r\n\tlet\r\n\t\tanswer,\r\n\t\targs: Array<any> = message.data.args,\r\n\t\tfuncName = message.data.funcName,\r\n\t\tmessageId: string = message.data.id;\r\n\ttry {\r\n\t\tswitch (funcName) {\r\n\t\t\tcase \"findPrime\":\r\n\t\t\t\tanswer = findPrime(args[0] as number); break;\r\n\t\t\tcase \"convertToBase\":\r\n\t\t\t\tanswer = convertToBase(args[0] as string, args[1], args[2]); break;\r\n\t\t\tcase \"quadraticRoots\":\r\n\t\t\t\tanswer = quadraticRoots(args[0]); break;\r\n\t\t\tcase \"polynomialExpand\":\r\n\t\t\t\tanswer = polynomialExpand(args[0]);\r\n\r\n\t\t}\r\n\t\tpostMessage({ answer, id: messageId, type: \"answer\" });\r\n\t} catch (error) {\r\n\t\tdispatchError(error, messageId);\r\n\t}\r\n}\r\n\r\nfunction dispatchError(error: any, id: string) {                                                  //dispatches an error from a worker to its creator\r\n\tvar errorClone: {[prop: string]: any}= {}, errorProperties = Object.getOwnPropertyNames(error);\r\n\tfor (let i of errorProperties) {\r\n\t\terrorClone[i] = error[i];\r\n\t}\r\n\tpostMessage({ type: \"error\", errorClone, id });\r\n}","import { Fraction, isSquare, makeWhole, parse, sqRoot } from \"../utils\";\r\nexport function quadraticRoots(func: string){\r\n\t// let variable, illegalToken, variableCheck=/[a-zA-Z]/g;\r\n\t// if(/[a-zA-Z]/.test(func)) var x = variable = /[a-zA-Z]/.exec(func)[0];                                    //the variable in func\r\n\t// else throw new Error(\"Argument Is Not A Quadratic Function.\");\r\n\t// try{\r\n\t// \tlet a_match = ``, b_match = ``, c_match, value;\r\n\t// \tvar b_pattern = new RegExp(`([\\\\+\\\\-](\\\\d*(?:\\\\.\\\\d+)?)?${x}(?![^\\\\+\\\\-]*2))|(^(\\\\d*(?:\\\\.\\\\d+)?)?${x}(?![^\\\\+\\\\-]*2))`),                   //positive/negative integer/decimal number before x but not x(2)\r\n\t// \tc_pattern = new RegExp(`([\\\\+\\\\-](\\\\d+(?:\\\\.\\\\d+)?|(?:\\\\.\\\\d+))(?![${x}\\\\d\\\\.]))|(^((\\\\d+(?:\\\\.\\\\d+)?)|((?:\\\\.\\\\d+)))(?![${x}\\\\d\\\\.]))`),                            //positive/negative integer/decimal no. that doesn't occur before an x\r\n\t// \ta_pattern = new RegExp(`[\\\\+\\\\-]?(\\\\d*(?:\\\\.\\\\d+)?)?${x}\\\\^?\\\\(?2\\\\)?`),                       //positive/negative integer/decimal no. before x(2)\r\n\t// \tfuncWithoutA =func.replace(new RegExp(a_pattern,\"g\"),\"\"),                                      //remove a from func, for c_pattern not to match 2\r\n\t// \ta = (~func.search(a_pattern) && !isNaN(value = parseFloat(a_match = func.match(a_pattern)[0]))? value : \r\n\t// \t~a_match.search(`-${x}`)? -1 : ~a_match.search(`^[\\+]?${x}`)? 1 : 0),\r\n\t// \tb = (~func.search(b_pattern) && !isNaN(value = parseFloat(b_match = func.match(b_pattern)[0]))? value :      //set b to 0 or the occurence of b_pattern\r\n\t// \t~b_match.search(`-${x}`)? -1 : ~b_match.search(`^[\\+]?${x}`)? 1 : 0),\r\n\t// \tc = (c_match = funcWithoutA.match(c_pattern))? parseFloat(c_match[0]) : 0;                     //set c to 0 or the occurence of c_pattern\r\n\t// }\r\n\t// catch(error){\r\n\t// \tif(func==\"\") throw new Error(\"No Arguments Supplied\");\r\n\t// \tthrow new Error(\"Invalid format!\");\r\n\t// }\r\n\t// checkforErrors: {\r\n\t// \twhile(variableCheck.test(func)){\r\n\t// \t\tif(func[variableCheck.lastIndex-1] !== variable) throw new Error(\"Function Is Not In One Variable\");\r\n\t// \t};\r\n\t// \ta_pattern.lastIndex=b_pattern.lastIndex=c_pattern.lastIndex = 0;\r\n\t// \tvariableCheck = /[a-zA-Z]/g;\r\n\t// \tif(!illegalToken){ a_pattern.lastIndex=b_pattern.lastIndex=c_pattern.lastIndex=0;\r\n\t// \t\tif(func.match(/\\(/) && !func.match(/\\)/)) throw new Error (`Invalid Input! Unterminated \\(`);\r\n\t// \t\tif(func.match(/\\)/) && !func.match(/\\(/)) throw new Error(`Invalid Input! Unexpected token \\)`);\r\n\t// \t\tif(illegalToken=func.match(/[\\+\\-][\\+\\-]/) || func.match(/\\)[^\\+\\-]/)) throw new Error(`Invalid Input! Illegal Sequence ${illegalToken}`);\r\n\t// \t\tif(illegalToken=func.replace(a_pattern,\"\").replace(b_pattern,\"\").replace((funcWithoutA.match(c_pattern))? funcWithoutA.match(c_pattern)[0]: \"\",\"\")) throw new Error(`Invalid Input! Unexpected Token ${illegalToken+(func[func.lastIndexOf(illegalToken[illegalToken.length-1])+1]||\" \")}`);\r\n\t// \t}\r\n\t// \tif(a==0) throw new Error(\"Argument Is Not A Quadratic Function\");\r\n\t\t\r\n\t// };\r\n\tvar variable,\r\n\ta = 0,\r\n\tb = 0,\r\n\tc = 0;\r\n\tvar poly = parse(func).flatten();\r\n\tif (poly.multivariable) throw new TypeError(\"Input has more than one variable\");\r\n\tif (poly.degree != 2) throw new TypeError(\"Input is not a quadratic function\");\r\n\tfor (let term of poly.terms) {\r\n\t\tif (!term.variables.length)  {\r\n\t\t\tc = term.coefficient;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (term.variables[0].power == 2) {\r\n\t\t\ta = term.coefficient;\r\n\t\t\tvariable = term.variables[0].base;\r\n\t\t}\r\n\t\telse if (term.variables.length === 1 && term.variables[0].power == 1) b = term.coefficient;\r\n\t\telse throw new TypeError(\"Input is not a quadratic function\");\r\n\t}\r\n\tvar wholes = makeWhole(a,b,c);                                        //make all the coefficients  whole numbers\r\n\t\ta = wholes.numbers[0], b = wholes.numbers[1], c = wholes.numbers[2];\r\n\tlet D = (b * b) - 4 * (a * c);\r\n\tif((D>=0) && isSquare(D)){                       //if determinant is a positive perfect square\r\n\t\tvar ans1num = -b + Math.sqrt(D), ans1 = new Fraction(ans1num,2*a).toLowestTerms();\r\n\t\tvar ans2num = -b - Math.sqrt(D), ans2 = new Fraction(ans2num,2*a).toLowestTerms();\r\n\t\treturn {type:\"simple\",ans1,ans2,variable}\r\n\t}\r\n\telse{\r\n\t\tvar determinant = new Fraction(sqRoot(D),2*a).toLowestTerms();                                    //find the square root of the determinant(in surd/complex form) and divide it by 2a\r\n\t\tdeterminant.nume = determinantNumeFormat(String(determinant.nume));                                         //format the numerator for display. \r\n\t\tvar first = new Fraction(-b,2*a).toLowestTerms();                                                   //divide the first part(-b) by 2a and reduce to lowest terms\r\n\t\treturn {type:\"surd/complex\",first,determinant,variable};\r\n\t}\r\n\t\r\n\t//HELPER FUNCTIONS\r\n\t\r\n\tfunction determinantNumeFormat(nume: string){\r\n\t\tvar f = parseInt(nume);\r\n\t\tif(f) nume = nume.replace(f.toString(), f==1 || f==-1? \"\":f.toString());            //We don't need unity coefficient in front of squareRoot\r\n\t\tif(nume[0]==\"-\") nume = nume.replace(/^-/,\"\");                                 //Because of the (+-) to appear before the numerator, - sign doesn't matter at all\r\n\t\treturn nume\r\n\t};\r\n}\r\n","import { parse } from \"../utils\";\r\n\r\nexport function polynomialExpand(func: string){\r\n\t// let nC, sA, sB, sC;                                               //Numeric coefficient, sign coefficient\r\n\t// var a_match = /[\\+\\-]?\\w+(?=[\\+\\-])/,\r\n\t// b_match = /[\\+\\-]\\w+(?=\\))/,\r\n\t// n_match = /((\\([\\+]?\\d+\\))|([\\+]?\\d+))$/,\r\n\t// n =  n_match.test(func)?  parseInt(n_match.exec(func)[0].replace(/^[^\\+\\-\\d]+/,\"\")): 1,\r\n\t// a = new String(a_match.exec(func)[0]),\r\n\t// b = new String(b_match.exec(func)[0]);\r\n\t// a.sign = b.sign = 1; \r\n\t// if(sC = /^[\\-\\+]/.exec(a)){                           //if a is prefixed with a sign, \r\n\t// \ta = new String(a.replace(sC[0],\"\"));              // remove the sign and multiply the coefficient by it\r\n\t// \ta.sign =  sC[0]+1;\r\n\t// }\r\n\t// if(sC = /^[\\-\\+]/.exec(b)){\r\n\t// \tb = new String(b.replace(sC[0],\"\"));\r\n\t// \tb.sign =  sC[0]+1;\r\n\t// }\r\n\t// if(nC=parseInt(a)){\r\n\t// \tlet sign = a.sign;\r\n\t// \ta = new String(a.replace(/^[\\+\\-]?\\d+/,\"\"))\r\n\t// \tsign? (a.sign = sign*nC): (a.sign = nC); \r\n\t// }\r\n\t// if(nC=parseInt(b)){\r\n\t// \tlet sign = b.sign;\r\n\t// \tb = new String(b.replace(/^[\\+\\-]?\\d+/,\"\"))\r\n\t// \tsign? (b.sign = sign*nC): (b.sign = nC); \r\n\t// }\r\n\t// if((sA = new Set(a)).size != a.length){\r\n\t// \tlet duplicates = a;\r\n\t// \tfor(let i of sA){\r\n\t// \t\tduplicates = duplicates.replace(i,\"\");\r\n\t// \t}\r\n\t// \tif(duplicates) throw new Error(`Duplicates {${Array.from(new Set(duplicates)).join()}} not allowed in left variable`)\r\n\t// };\r\n\t// if((sB = new Set(b)).size != b.length){\r\n\t// \tlet duplicates = b;\r\n\t// \tfor(let i of sB){\r\n\t// \t\tduplicates = duplicates.replace(i,\"\");\r\n\t// \t}\r\n\t// \tif(duplicates) throw new Error(`Duplicates {${Array.from(new Set(duplicates)).join()}} not allowed in right variable`)\r\n\t// }\r\n\t\r\n\r\n\t\r\n\t// let  power = 0, terms = [];\r\n\t// while(power<=n){\r\n\t// \tlet\r\n\t// \t\tcoefficient = utils.combination(n,power)*Math.pow(a.sign,n-power)*Math.pow(b.sign,power),                  //n Combination p\r\n\t// \t\tfvar = new utils.Exponential(a,n-power),                     //set first variable to a^(n-p)\r\n\t// \t\tsvar = new utils.Exponential(b,power);                       //set Second variable to b^(p)\r\n\t// \t\tterms.push(new utils.Term(coefficient,fvar,svar));         //collect all in a new term.\r\n\t// \t\t++power\r\n\t// };\r\n\t// return terms;\r\n\treturn parse(func).flatten().terms;\r\n};\r\n"],"names":["restorePrototype","obj","extension","__proto__","extensions","prototype","prop","disableForm","form","Array","forEach","call","elements","e","disabled","readOnly","type","style","cursor","enableForm","factorsCache","length","Object","keys","this","factors","x","Math","abs","answer","increment","i","floor","sqrt","right","left","m","n","p","q","push","Set","reduce","list","every","s","sort","a","b","isSquare","sqr","makeWhole","numbers","formattedNumbers","map","String","indexOf","toFixed","replace","toString","highestDecimalDigits","Number","isInteger","h","max","decimalDigits","round","pow","sqRoot","nP","result","nP_fcList","j","lowestRatios","fctList","min","isFactorOf","bind","divide","combination","factorial","count","ans","Fraction","constructor","nume","denom","arguments","whole","toLowestTerms","t","d","top","bottom","reducedRatios","isNaN","parseFloat","valueOf","Term","args","index","coefficient","splice","variables","product","arg","processedArg","compareBase","Exponential","base","add","power","processedvariable","argvariable","toAdd","already","comparePower","isString","multiply","localeCompare","isAddable","other","outerLoop","thisVariable","otherVariable","flatten","variable","cumulativeProduct","pol","Polynomial","str","Tree","cargo","_toFormat","tree","width","height","offset","isLeaf","repeat","Error","replaceNode","node","newNode","currentTreeNode","getRightMost","rightMost","extend","value","previousValue","print","indent","console","log","terms","processTerms","term","variableLetters","letter","split","processedTerm","sum","NaN","thisTerms","otherTerms","thisTerm","otherTerm","allTerms","termsa","termsb","concat","multivariable","size","degree","join","compareComponents","flattenedBase","newCumulative","terma","termb","simplifiedBase","simplifiedPower","flattenedPower","tokenize","expr","tokens","lastIndex","numberMatcher","exec","slice","getToken","token","test","shift","peekToken","getSingleTerm","number","sign","getOperator","getLParans","getRParans","getRank","operator","getAllTerms","rootNode","currentNode","rightmostNode","parenthesisIndices","last","SyntaxError","topNode","pop","main","operand","bTerm","aTerm","parse","expression","evaluate","substring","negativeTerm","subtract","TypeError","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","definition","key","o","defineProperty","enumerable","get","hasOwnProperty","r","Symbol","toStringTag","utils","primeCache","isPrime","limit","onmessage","message","data","_subworker","funcName","messageId","id","nearestIndex","least","num","findPrime","newBase","toLowerCase","charCodeAt","base10ToBaseN","MAX_SAFE_INTEGER","numberFixed","floatResult","wholeResultDigits","pointIndex","Infinity","float","fraction","digit","fromCharCode","wholeResult","reverse","placeDigit","placeValue","toBase10","convertToBase","func","c","poly","wholes","D","ans1num","ans1","ans2num","ans2","f","determinant","parseInt","first","quadraticRoots","postMessage","error","errorClone","errorProperties","getOwnPropertyNames","dispatchError"],"sourceRoot":""}