{"version":3,"file":"workers/childworker.js","mappings":"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","sources":["webpack://math-util/./src/scripts/utils.ts","webpack://math-util/webpack/bootstrap","webpack://math-util/webpack/runtime/define property getters","webpack://math-util/webpack/runtime/hasOwnProperty shorthand","webpack://math-util/webpack/runtime/make namespace object","webpack://math-util/./src/scripts/solvers/baseConverter.ts","webpack://math-util/./src/scripts/solvers/prime.ts","webpack://math-util/./src/scripts/workers/childWorker.ts","webpack://math-util/./src/scripts/solvers/quadratic.ts","webpack://math-util/./src/scripts/solvers/polynomial.ts"],"sourcesContent":["\r\n\r\nfunction restorePrototype(obj: any): any {\r\n\tif (typeof obj == \"object\") {\r\n\t\tif (obj.extension) obj.__proto__ = extensions[obj.extension].prototype;\r\n\t\tfor (let prop in obj) {\r\n\t\t\tlet val = obj[prop];\r\n\t\t\trestorePrototype(val);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction disableForm(form: HTMLFormElement) {\r\n\tArray.prototype.forEach.call(form.elements, e => {\r\n\t\te.disabled = e.readOnly = true;\r\n\t\tif (e.__proto__ === `HTMLButtonElementPrototype` || e.type === \"submit\") e.style.cursor = `wait`;\r\n\t});\r\n}\r\n\r\nfunction enableForm(form: HTMLFormElement) {\r\n\tArray.prototype.forEach.call(form.elements, e => {\r\n\t\te.disabled = e.readOnly = false;\r\n\t\tif (e.__proto__ === `HTMLButtonElementPrototype` || e.type === \"submit\") e.style.cursor = `default`;\r\n\t});\r\n}\r\n\r\nfunction isWholeNumber(n: number) {\r\n\treturn n % 1 == 0;\r\n}\r\nconst factorsCache: { [n: number]: number[], get length(): number } = {\r\n\tget length() {\r\n\t\treturn Object.keys(this).length;\r\n\t}\r\n};\r\nfunction factors(x: number): number[] { //returns all the positive integer factors of x, including x\r\n\tx = Math.abs(x);\r\n\tif (x in factorsCache) return factorsCache[x]; //if x has already been solved before, then return the value\r\n\tvar answer = [x],\r\n\t\tincrement = (x % 2 == 0 ? 1 : 2),\r\n\t\tbase = ((x % 2 == 0 ? 2 : 3)); //if x is an odd number, then check only the odd numbers. Otherwise check both odd & even no.s\r\n\tfor (var i = base; i <= Math.floor(Math.sqrt(x)); i += increment) {\r\n\t\tif (x % i == 0) {\r\n\t\t\t;\r\n\t\t\tvar right = factors(x / i),\r\n\t\t\t\tleft = factors(i); //when a factor of x is found, find it's complement, evaluate both their factors & combine them..\r\n\t\t\tanswer = [...answer, ...right, ...left]; //to get the complete factors. (This is because the factors of a number is the product of the..\r\n\t\t\tfor (var m = 0, n = right[m]; m < right.length; ++m, n = right[m]) { //combination of the factors of any of it's complementary factors.\r\n\t\t\t\tfor (var p = 0, q = left[p]; p < left.length; ++p, q = left[p]) {\r\n\t\t\t\t\tif (n * q !== x) answer.push(n * q);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tif (Set) { //remove all duplicate values in answer\r\n\t\t\t\tanswer = [...(new Set(answer))];\r\n\t\t\t} else {\r\n\t\t\t\tanswer = answer.reduce(function (list: number[], n) {\r\n\t\t\t\t\tif (list.every(function (s) {\r\n\t\t\t\t\t\treturn s !== n\r\n\t\t\t\t\t})) {\r\n\t\t\t\t\t\tlist.push(n);\r\n\t\t\t\t\t};\r\n\t\t\t\t\treturn list;\r\n\t\t\t\t}, []);\r\n\t\t\t}\r\n\t\t\tanswer = answer.sort(function (a, b) {\r\n\t\t\t\treturn a - b\r\n\t\t\t});\r\n\t\t\tfactorsCache[x] = answer;\r\n\t\t\treturn answer;\r\n\t\t}\r\n\t}\r\n\tfactorsCache[x] = answer;\r\n\treturn [x]\r\n}\r\n\r\nfunction isSquare(x: number) { //Returns a boolean indicating whether or not x is a perfect square\r\n\tconst sqr = Math.sqrt(x);\r\n\treturn sqr == Math.floor(sqr) ? true : false\r\n};\r\n\r\nfunction makeWhole(...numbers: number[]): { numbers: number[], decimalDigits: number } { //returns all of numbers as whole by multiplying through by 10^ highest number of decimal digits\r\n\tconst formattedNumbers: string[] = numbers.map(n => ~String(n).indexOf(\"e\") ? n.toFixed(15).replace(/0+$/, ``) : n.toString()); //collect all arguments in string form\r\n\t//determine the highest number of decimal digits in numbers\r\n\tlet highestDecimalDigits = formattedNumbers.every(Number.isInteger) ? 0 : formattedNumbers.reduce((h, n) => Math.max(h, (~n.indexOf(\".\")) ? (n.length - 1) - n.indexOf(\".\") : 0), 0);\r\n\treturn { decimalDigits: highestDecimalDigits, numbers: formattedNumbers.map(n => Math.round(Number(n) * Math.pow(10, highestDecimalDigits))) } //multiply all of the numbers by 10^ the highest decimal digits count\r\n};\r\n\r\nfunction sqRoot(n: number /*number*/) { //Returns the square root of n. returns a surd or a complex number where applicable\r\n\tvar nP = Math.abs(n); //set nP to the positive value of n\r\n\tlet result: string | number = \"\\u221A\" + n; //set result to root n, if n isn't a perfect square and neither is any of it's factors.\r\n\tif (isSquare(nP)) {\r\n\t\tresult = (n >= 0) ? Math.sqrt(nP) : Math.sqrt(nP) + \"\\u221A\" + -1; //if nP is a perfect square, set result to root n if n was positive else, set to root n * root -1\r\n\t} else {\r\n\t\tfor (var nP_fcList = factors(nP), i = nP_fcList.length - 1, j = nP_fcList[i]; i > -1; --i, j = nP_fcList[i]) { //Take the highest perfect square factor of xP if any,..\r\n\t\t\tif (isSquare(j)) {\r\n\t\t\t\tresult = Math.sqrt(j) + \"\\u221A\" + n / j;\r\n\t\t\t\tbreak; //..factor it out and multiply it's root by what is left under the square root sign.\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn result\r\n}\r\n\r\nfunction lowestRatios(...numbers: number[]) { //returns the lowest integer ratios of all the numbers\r\n\tvar answer = makeWhole(...numbers),\r\n\t\tlowest = Math.min(...answer.numbers),\r\n\t\tfctList = factors(lowest); //select the lowest number in the arguments and find its factors\r\n\tfor (var i = fctList.length - 1, j = fctList[i]; i >= 0; --i, j = fctList[i]) {\r\n\t\tif (answer.numbers.every(isFactorOf.bind(null, j))) { //if all other arguments are divisible by any of the factors, highest to lowest,..\r\n\t\t\treturn answer.numbers.map(n => n / j); //then divide them through by the factor and return\r\n\t\t}\r\n\t}\r\n\treturn answer.numbers; //if none of the factors could divide through, then return the original arguments\r\n}\r\n\r\nfunction isFactorOf(x: number, n: number) {\r\n\treturn n % x == 0;\r\n}\r\n\r\nfunction combination(n: number, m: number) {\r\n\treturn factorial(n) / (factorial(n - m) * factorial(m));\r\n}\r\n\r\nfunction factorial(n: number) {\r\n\tlet count = n,\r\n\t\tans = 1;\r\n\twhile (count > 0) {\r\n\t\tans *= count;\r\n\t\t--count;\r\n\t}\r\n\treturn ans;\r\n}\r\n\r\n//class definitions\r\n/*\r\n * instances \"extension\" property are used to restore their prototype when they are transferred to/from workers.\r\n */\r\nclass Fraction {\r\n\textension = \"Fraction\";\r\n\tnume: number | string;\r\n\tdenom: number | string\r\n\tconstructor(nume: number | string, denom: number | string) {\r\n\t\tif (arguments.length == 2) {\r\n\t\t\t//if one argument is supplied, then represent it as a fraction, otherwise, make a fraction from two arguments supplied.\r\n\t\t\tthis.nume = nume;\r\n\t\t\tthis.denom = denom;\r\n\t\t} else {\r\n\t\t\tif (typeof nume == \"number\") {\r\n\t\t\t\tlet whole = makeWhole(nume);\r\n\t\t\t\tthis.nume = whole.numbers[0];\r\n\t\t\t\tthis.denom = Math.pow(10, whole.decimalDigits);\r\n\t\t\t} else {\r\n\t\t\t\tthis.nume = nume;\r\n\t\t\t\tthis.denom = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ttoLowestTerms() { //returns the fraction in it's lowest terms.\r\n\t\tlet t, d, top, bottom, reducedRatios, n = String(this.nume),\r\n\t\t\tdenom = String(this.denom);\r\n\t\tif (!isNaN(t = parseFloat(n)) && !isNaN(d = parseFloat(denom))) {\r\n\t\t\treducedRatios = lowestRatios(t, d);\r\n\t\t\ttop = reducedRatios[0];\r\n\t\t\tbottom = reducedRatios[1]\r\n\t\t\tif (bottom < 0) bottom = -bottom, top = -top; //make the denominator positive\r\n\t\t\tn = n.replace(t.toString(), top.toString()); //replace the coefficients\r\n\t\t\tdenom = denom.replace(d.toString(), bottom.toString());\r\n\t\t} else {\r\n\t\t\tif (denom[0] == \"-\") denom = denom.replace(/^-/, \"\"), n = n[0] == \"-\" ? n.replace(/^-/, \"\") : \"-\" + n;\r\n\t\t}\r\n\t\treturn new Fraction(n, denom);\r\n\t}\r\n\tvalueOf() {\r\n\t\treturn Number(this.nume) / Number(this.denom)\r\n\t}\r\n}\r\n\r\nclass Term {\r\n\textension = \"Term\";\r\n\tcoefficient: number = 1;\r\n\tvariables: Exponential[];\r\n\tconstructor(...args: Exponential[]) {\r\n\t\tfor (let index = 0; index < args.length; index++) {\r\n\t\t\tif (!isNaN(Number(args[index]))) {\r\n\t\t\t\tthis.coefficient *= Number(args[index]);\r\n\t\t\t\targs.splice(index--, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.variables = args.reduce((product: Exponential[], arg) => {\r\n\t\t\tfor (let i = 0, processedArg: Exponential; i < product.length; i++) {\r\n\t\t\t\tprocessedArg = product[i];\r\n\t\t\t\tif (processedArg.compareBase(arg) == 0) {   //if the variable has equivalent base as arg, add arg's power to it\r\n\t\t\t\t\tproduct[i] = new Exponential(processedArg.base, add(product[i].power, arg.power));\r\n\t\t\t\t\treturn product;\r\n\t\t\t\t} else if (typeof (arg.base) == \"string\" && typeof (processedArg.base) == \"string\")\r\n\t\t\t\t\tfor (let processedvariable of processedArg.base) {\r\n\t\t\t\t\t\tfor (let argvariable of arg.base as string) {\r\n\t\t\t\t\t\t\tif (argvariable == processedvariable) {                               //if a single letter of arg is in productvariable\r\n\t\t\t\t\t\t\t\tlet toAdd;\r\n\t\t\t\t\t\t\t\ttoAdd = new Exponential(processedvariable, add(processedArg.power, arg.power));\r\n\t\t\t\t\t\t\t\tprocessedArg = product[i] = new Exponential((processedArg.base as string).replace(processedvariable, \"\"), processedArg.power);\r\n\t\t\t\t\t\t\t\tif (!(product[i].base)) product.splice(i--, 1);\r\n\t\t\t\t\t\t\t\targ = new Exponential((arg.base as string).replace(processedvariable, \"\"), arg.power);\r\n\t\t\t\t\t\t\t\tif (product.length) {\r\n\t\t\t\t\t\t\t\t\tfor (let already in product) {\r\n\t\t\t\t\t\t\t\t\t\tif (product[already].comparePower(toAdd) == 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (isString(toAdd.base) && isString(product[already].base)) product[already] = new Exponential((product[already].base as string) + toAdd.base, product[already].power);\r\n\t\t\t\t\t\t\t\t\t\t\telse product[already] = new Exponential(multiply(product[already].base, toAdd.base), product[already].power);\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t} else if (Number(already) == product.length - 1) {\r\n\t\t\t\t\t\t\t\t\t\t\tproduct.push(toAdd);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tproduct.push(toAdd);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (Number(arg) == 0) return product; //arg's base may have been exhausted\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\tif (product[i]) {\r\n\t\t\t\t\tif (product[i].comparePower(arg) == 0) {\r\n\t\t\t\t\t\tif (isString(arg.base) && isString(product[i].base)) product[i] = new Exponential((product[i].base as string) + arg.base, product[i].power);\r\n\t\t\t\t\t\telse product[i] = new Exponential(multiply(product[i].base, arg.base), product[i].power);\r\n\t\t\t\t\t\treturn product;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (arg.base) product.push(arg);\r\n\r\n\t\t\treturn product;\r\n\t\t}, []);\r\n\t\tthis.variables.sort((a, b) => {\r\n\t\t\tif (isString(a.base)) {\r\n\t\t\t\tif (isString(b.base)) return (a.base as string).localeCompare(b.base as string);        //arrange variables in aphabetical order\r\n\t\t\t\telse return -1;      //complex term should come last\r\n\t\t\t} else {\r\n\t\t\t\tif (isString(b.base)) return 1;\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\tvalueOf() {\r\n\t\tif (this.coefficient == 0) return 0;\r\n\t\treturn this.variables.reduce((a, b) => Number(a) * Number(b), this.coefficient)\r\n\t}\r\n\r\n\tisAddable(other: Term) {\r\n\t\tif (this.variables.length != other.variables.length) return false;\r\n\t\touterLoop: for (let thisVariable of this.variables) {\r\n\t\t\tfor (let otherVariable of other.variables) {\r\n\t\t\t\tif (thisVariable.comparePower(otherVariable) != 0) continue;  //variables do not match\r\n\t\t\t\tif (thisVariable.compareBase(otherVariable) == 0) continue outerLoop; //both base and power match\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tflatten() {\r\n\t\tconst flattenedVariables = this.variables.map(variable => variable.flatten());\r\n\t\treturn flattenedVariables.reduce(\r\n\t\t\t(cumulativeProduct, pol) => multiply(cumulativeProduct, pol),\r\n\t\t\tnew Polynomial(this.coefficient));\r\n\t}\r\n\r\n}\r\n\r\n\r\nfunction isString(str: any) { return typeof (str) == \"string\" || str instanceof String; }\r\n\r\nclass Tree<T> {\r\n\tcargo: T;\r\n\tleft: Tree<T> | null;\r\n\tright: Tree<T> | null;\r\n\r\n\tconstructor(cargo: T, left: Tree<T> | null = null, right: Tree<T> | null = null) {\r\n\t\t[this.cargo, this.left, this.right] = [cargo, left, right]\r\n\t}\r\n\ttoString() {\r\n\t\tfunction _toFormat(tree: Tree<T>, width: number, height: number, offset: number) {\r\n\t\t\toffset += width;\r\n\t\t\tlet str = \"\";\r\n\t\t\tif (tree.isLeaf) return str + \" \".repeat(offset) + String(tree.cargo) + \"\\n\".repeat(height);\r\n\t\t\telse if (!(tree.left && tree.right)) throw new Error(\"not a tree\");\r\n\t\t\tstr += _toFormat(tree.left, width, height, offset);\r\n\t\t\tstr += \" \".repeat(offset) + String(tree.cargo) + \"\\n\".repeat(height);\r\n\t\t\tstr += _toFormat(tree.right, width, height, offset);\r\n\t\t\treturn str;\r\n\t\t}\r\n\t\treturn _toFormat(this, 8, 1, -8)\r\n\t}\r\n\r\n\tget isLeaf() {\r\n\t\treturn this.left == null && this.right == null ? true : false;\r\n\t}\r\n\treplaceNode(node: Tree<T>, newNode: Tree<T>) {\r\n\t\tlet currentTreeNode: Tree<T> = this;\r\n\t\twhile (currentTreeNode.right) {\r\n\t\t\tif (currentTreeNode.right == node) {\r\n\t\t\t\tcurrentTreeNode.right = newNode;\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tcurrentTreeNode = currentTreeNode.right;\r\n\t\t}\r\n\t}\r\n\r\n\tgetRightMost() {\r\n\t\tlet rightMost: Tree<T> = this;\r\n\t\twhile (rightMost.right instanceof Tree) rightMost = rightMost.right;\r\n\t\treturn rightMost;\r\n\t}\r\n\r\n\textend(value: T) {\r\n\t\tlet previousValue = this.cargo;\r\n\t\tthis.cargo = value;\r\n\t\tthis.left = new Tree(previousValue, this.left, this.right);\r\n\t\tthis.right = null;\r\n\t}\r\n\r\n\tprint(indent: number) {\r\n\t\tconsole.log('  '.repeat(indent) + (this.cargo as Object).toString());\r\n\t\tif (this.left) this.left.print(indent + 5);\r\n\t\tif (this.right) this.right.print(indent + 5);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nclass Polynomial {\r\n\tterms: Term[] = [];\r\n\tvariableLetters: Set<string> = new Set;\r\n\textension: string = \"Polynomial\";\r\n\r\n\tconstructor(terms: Term[] | Term | number | string = []) {\r\n\t\tif (typeof terms == \"number\" || typeof terms == \"string\") terms = [new Term(new Exponential(terms))];\r\n\t\telse if (terms instanceof Term) terms = [terms];\r\n\t\tprocessTerms: for (let term of terms) {\r\n\t\t\tif (Number(term) == 0) continue;\r\n\t\t\tfor (let variable of term.variables) {\r\n\t\t\t\tif (variable.base instanceof Polynomial) variable.base.variableLetters.forEach(letter => this.variableLetters.add(letter));\r\n\t\t\t\telse if (typeof variable.base == \"string\") this.variableLetters = new Set([...this.variableLetters, ...variable.base.split(\"\")]);\r\n\t\t\t\tif (variable.power instanceof Polynomial) variable.power.variableLetters.forEach(letter => this.variableLetters.add(letter));\r\n\t\t\t\telse if (typeof variable.power == \"string\") this.variableLetters = new Set([...this.variableLetters, ...variable.power.split(\"\")]);\r\n\t\t\t}\r\n\t\t\tfor (let index = 0, processedTerm: Term; index < this.terms.length; index++) {\r\n\t\t\t\tprocessedTerm = this.terms[index];\r\n\t\t\t\tif (processedTerm.isAddable(term)) {\r\n\t\t\t\t\tconst sum = new Term();\r\n\t\t\t\t\tsum.coefficient = processedTerm.coefficient + term.coefficient;  //do not modify any supplied term\r\n\t\t\t\t\tsum.variables = processedTerm.variables;\r\n\t\t\t\t\tprocessedTerm = this.terms[index] = sum;\r\n\t\t\t\t\tif (processedTerm.coefficient == 0) {\r\n\t\t\t\t\t\tthis.terms.splice(index--, 1);    //in case adding produced 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue processTerms;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.terms.push(term);\r\n\t\t}\r\n\t}\r\n\r\n\tvalueOf() {\r\n\t\treturn this.terms.reduce((sum, term) => sum + Number(term), 0)\r\n\t}\r\n\r\n\tlocaleCompare(other: Polynomial | number | string) {\r\n\t\tif (typeof other == \"string\") other = new Polynomial(other);\r\n\t\telse if (typeof other == \"number\") other = new Polynomial(other);\r\n\t\tif (this.terms.length != other.terms.length) return NaN;\r\n\t\tconst [thisTerms, otherTerms] = [this.flatten().terms, other.flatten().terms]\r\n\t\touterLoop: for (const thisTerm of thisTerms) {\r\n\t\t\tfor (let index = 0; index < otherTerms.length; index++) {\r\n\t\t\t\tconst otherTerm = otherTerms[index];\r\n\t\t\t\tif (thisTerm.coefficient == otherTerm.coefficient && thisTerm.isAddable(otherTerm)) {\r\n\t\t\t\t\totherTerms.splice(index--, 1);\r\n\t\t\t\t\tcontinue outerLoop;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\t\tif (otherTerms.length) return NaN;\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\tadd(term: Term) {\r\n\t\tif (Number(term) != 0) {\r\n\t\t\tfor (let variable of term.variables) {\r\n\t\t\t\tif (variable.base instanceof Polynomial) variable.base.variableLetters.forEach(letter => this.variableLetters.add(letter));\r\n\t\t\t\telse this.variableLetters = new Set([...this.variableLetters, ...(typeof variable.base == \"string\" ? variable.base.split(\"\") : \"\")]);\r\n\t\t\t\tif (variable.power instanceof Polynomial) variable.power.variableLetters.forEach(letter => this.variableLetters.add(letter));\r\n\t\t\t\telse this.variableLetters = new Set([...this.variableLetters, ...(typeof variable.power == \"string\" ? variable.power.split(\"\") : \"\")]);\r\n\r\n\t\t\t}\r\n\t\t\tfor (let index = 0, processedTerm; index < this.terms.length; index++) {\r\n\t\t\t\tprocessedTerm = this.terms[index];\r\n\t\t\t\tif (processedTerm.isAddable(term)) {\r\n\t\t\t\t\tconst sum = new Term();\r\n\t\t\t\t\tsum.variables = term.variables;\r\n\t\t\t\t\tconst coefficient = sum.coefficient = processedTerm.coefficient + term.coefficient;\r\n\t\t\t\t\tthis.terms[index] = sum; //do not modify any supplied terms\r\n\t\t\t\t\tif (coefficient == 0) {\r\n\t\t\t\t\t\tthis.terms.splice(index--, 1);    //in case adding produced 0\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.terms.push(term);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tflatten() {\r\n\t\tif (this.terms.length == 0) return this;\r\n\t\tconst allTerms = [...this.terms.map(term => term.flatten().terms).reduce((termsa, termsb) => termsa.concat(termsb))]\r\n\t\treturn new Polynomial(allTerms);\r\n\t}\r\n\r\n\tget multivariable() {\r\n\t\treturn this.variableLetters.size > 1;\r\n\t}\r\n\tget degree() {\r\n\t\tlet degree = 0;\r\n\t\tfor (const term of this.terms) {\r\n\t\t\tfor (const variable of term.variables) {\r\n\t\t\t\tdegree = Math.max(degree, Number(variable.power));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn degree;\r\n\t}\r\n\tget length() {\r\n\t\treturn this.terms.length\r\n\t}\r\n}\r\n\r\nclass Exponential {\r\n\tpower: Polynomial | string | number;\r\n\tbase: Polynomial | string | number;\r\n\textension: string = \"Exponential\";\r\n\tconstructor(base: Polynomial | string | number);\r\n\tconstructor(base: Polynomial | string | number, power: Polynomial | string | number);\r\n\tconstructor(base: Polynomial | string | number, power: Polynomial | string | number = 1) {\r\n\t\tif (typeof base == \"number\" || !isNaN(Number(base))) this.base = Number(base); //if it can be converted to a number, then do so\r\n\t\telse if (typeof (base) == \"string\" || base instanceof String) this.base = base.split(\"\").sort().join(\"\");  //if it is a string, then sort it\r\n\t\telse {\r\n\t\t\t// if (base.terms.length == 1) { //if it has just one term, raise the power of the variables in the term\r\n\t\t\t// \tlet product = new Polynomial();\r\n\t\t\t// \tlet variables: Exponential[] = [];\r\n\t\t\t// \tfor (let variable of base.terms[0].variables) {\r\n\t\t\t// \t\tvariables.push(new Exponential(variable.base, multiply(variable.power, power))\r\n\t\t\t// \t\t);\r\n\t\t\t// \t}\r\n\t\t\t// \tif (!isNaN(Number(power))) variables.push(new Exponential(base.terms[0].coefficient ** Number(power)));\r\n\t\t\t// \telse variables.push(new Exponential(base.terms[0].coefficient, power));\r\n\t\t\t// \tproduct.add(new Term(...variables));\r\n\t\t\t// \tthis.base = product;\r\n\t\t\t// \tpower = 1;\r\n\t\t\t// } else \r\n\t\t\tthis.base = base; //otherwise, leave as is. Will require expansion \r\n\t\t}\r\n\t\tif (!isNaN(Number(power))) this.power = Number(power);\r\n\t\telse if (typeof power == \"string\" || power instanceof String) this.power = power.split(\"\").sort().join(\"\");\r\n\t\telse this.power = power;\r\n\t}\r\n\tvalueOf() {\r\n\t\tif (Number(this.base) == 1) return 1;\r\n\t\tif (Number(this.base) == 0) return 0;\r\n\t\treturn Math.pow(Number(this.base), Number(this.power.valueOf()));\r\n\t}\r\n\tcomparePower(other: Exponential) {\r\n\t\treturn this.compareComponents(this.power, other.power);\r\n\t}\r\n\tcompareComponents(a: Polynomial | string | number, b: Polynomial | string | number) {\r\n\t\tif (a.valueOf() == b.valueOf()) return 0;\r\n\t\tif (typeof a == \"string\" || a instanceof String) {\r\n\t\t\tif ((typeof b == \"string\" || b instanceof String) && a.localeCompare(b as string) == 0) return 0;\r\n\t\t\tif (b instanceof Polynomial && new Polynomial(new Term(new Exponential(a))).localeCompare(b) == 0) return 0;\r\n\t\t} else if (a instanceof Polynomial) {\r\n\t\t\tif (b instanceof Polynomial && a.localeCompare(b) == 0) return 0;\r\n\t\t\tif ((typeof b == \"string\" || b instanceof String) && new Polynomial(new Term(new Exponential(b))).localeCompare(a) == 0) return 0;\r\n\t\t}\r\n\t\treturn NaN\r\n\t}\r\n\tcompareBase(other: Exponential): number {\r\n\t\treturn this.compareComponents(this.base, other.base);\r\n\t}\r\n\tflatten(): Polynomial {\r\n\t\tif (!isNaN(Number(this))) return new Polynomial(Number(this));  //if they are both number\r\n\t\tlet flattenedBase: string | Polynomial | number = this.base instanceof Polynomial ? this.base.flatten() : this.base;\r\n\t\tif (!isNaN(Number(this.power))) {\r\n\t\t\tif (Number(this.power) >= 0 && isWholeNumber(Number(this.power)) && flattenedBase instanceof Polynomial) {\r\n\t\t\t\tlet power: number = Number(this.power);\r\n\t\t\t\tlet cumulativeProduct = flattenedBase;\r\n\t\t\t\twhile (power > 1) {\r\n\t\t\t\t\tcumulativeProduct = multiply(flattenedBase, cumulativeProduct);\r\n\t\t\t\t\tpower--;\r\n\t\t\t\t}\r\n\t\t\t\treturn cumulativeProduct;\r\n\r\n\t\t\t}\r\n\t\t\tif (flattenedBase instanceof Polynomial && flattenedBase.terms.length == 1 && flattenedBase.terms[0].coefficient == 1 && flattenedBase.terms[0].variables.length == 1) {\r\n\t\t\t\tconst newExp = new Exponential(flattenedBase.terms[0].variables[0].base, multiply(this.power, flattenedBase.terms[0].variables[0].power));\r\n\t\t\t\treturn new Polynomial(new Term(newExp));\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet simplifiedPower = this.power;\r\n\t\tif (flattenedBase instanceof Polynomial) {\r\n\t\t\tif (flattenedBase.terms.length == 1 && flattenedBase.terms[0].coefficient == 1 && flattenedBase.terms[0].variables.length == 1 && flattenedBase.terms[0].variables[0].power == 1) flattenedBase = flattenedBase.terms[0].variables[0].base;\r\n\t\t}\r\n\t\tif (simplifiedPower instanceof Polynomial) {\r\n\t\t\tlet flattenedPower: string | Polynomial | number = simplifiedPower.flatten();\r\n\t\t\tif (flattenedPower.terms.length == 1 && flattenedPower.terms[0].coefficient == 1 && flattenedPower.terms[0].variables.length == 1 && flattenedPower.terms[0].variables[0].power == 1) flattenedPower = flattenedPower.terms[0].variables[0].base;\r\n\t\t\tsimplifiedPower = flattenedPower;\r\n\t\t}\r\n\t\treturn new Polynomial(new Term(new Exponential(flattenedBase, simplifiedPower)));\r\n\t}\r\n}\r\n\r\nfunction tokenize(expr: string) {\r\n\texpr = expr.replace(/[\\s\\n\\t]+/g, \"\")\r\n\tlet result;\r\n\tlet tokens: string[] = [];\r\n\tlet lastIndex = 0;\r\n\tlet numberMatcher = /(\\d*\\.\\d+)|\\d+/g;\r\n\twhile (result = numberMatcher.exec(expr)) {\r\n\t\ttokens = tokens.concat(expr.slice(lastIndex, result.index).split(\"\"));\r\n\t\ttokens.push(result[0]);\r\n\t\tlastIndex = numberMatcher.lastIndex;\r\n\t}\r\n\ttokens = tokens.concat(expr.slice(lastIndex, expr.length).split(\"\"));;\r\n\ttokens.push(\"end\");\r\n\treturn tokens\r\n}\r\nfunction getToken(token: RegExp, tokens: string[]) {\r\n\tif (token.test(tokens[0])) {\r\n\t\treturn tokens.shift();\r\n\t}\r\n\treturn null\r\n}\r\n\r\nfunction peekToken(token: RegExp, tokens: string[]) {\r\n\treturn token.test(tokens[0])\r\n}\r\n\r\nfunction getSingleTerm(tokens: string[]) {\r\n\tlet coefficient = 1;\r\n\tlet value: string | number | null = null;\r\n\tlet variable, number, sign;\r\n\twhile (sign = getToken(/^[-+]$/, tokens)) {\r\n\t\tcoefficient *= Number(sign[0] + 1);\r\n\t}\r\n\tif (coefficient == -1 && peekToken(/^\\(/, tokens)) value = \"1\"; //a minus sign being before an opening paranthesis implies multiplication by -1\r\n\telse if (variable = getToken(/^[a-zA-Z]/, tokens)) value = variable;\r\n\telse if (number = getToken(/^(\\d*\\.\\d+)|\\d+/, tokens)) value = Number(0 + number);\r\n\tif (coefficient == 1 && value != null) value = \"+\" + value;\r\n\telse if (value != null) value = \"-\" + value;\r\n\treturn value\r\n}\r\nfunction getOperator(tokens: string[]) {\r\n\tlet token = getToken(/^[\\+\\-\\*\\/\\^]/, tokens);\r\n\tif (token) return token;\r\n\tif (peekToken(/^[a-zA-Z]/, tokens)) return \"*\"; //a digit/variable being before a variable implies multiplication\r\n\tif (peekToken(/^\\(/, tokens)) return \"*\"; //a digit/variable being before an opening paranthesis implies multiplication\r\n\treturn null;\r\n}\r\n\r\nfunction getLParans(tokens: string[]) {\r\n\tlet token = getToken(/^\\(/, tokens);\r\n\tif (token) return token;\r\n\treturn null;\r\n}\r\n\r\nfunction getRParans(tokens: string[]) {\r\n\tlet token = getToken(/\\)/, tokens);\r\n\tif (token) return token;\r\n\treturn null;\r\n}\r\n\r\nfunction getRank(operator: string) {\r\n\tif (/^[\\^]$/.test(operator)) return 1;\r\n\tif (/^[\\/\\*]$/.test(operator)) return 2;\r\n\tif (/^[\\+\\-]$/.test(operator)) return 3;\r\n\r\n}\r\n\r\nfunction getAllTerms(tokens: string[]): Tree<string | number> {\r\n\tlet rootNode: Tree<string | number> | null = null;\r\n\tlet currentNode: Tree<string | number> | null = null;\r\n\tlet rightmostNode: Tree<string | number> | null = null;\r\n\tlet parenthesisIndices: ({ main: Tree<string | number>, rightmostNode: Tree<string | number> } | null)[] = [];\r\n\tlet last: \"operator\" | \"term\" = \"operator\";\r\n\tlet term: Tree<string | number>;\r\n\tlet operator: string;\r\n\r\n\twhile (!getToken(/^end$/, tokens)) {\r\n\t\tif (getRParans(tokens)) {\r\n\t\t\tif (!parenthesisIndices.length) throw new SyntaxError(`Unexpected closing bracket: No matching opening bracket was found`);\r\n\t\t\tif (last == \"operator\") throw new SyntaxError(`Unexpected closing bracket: value or expression expected`);\r\n\t\t\tconst topNode = parenthesisIndices.pop();\r\n\t\t\trightmostNode = currentNode;\r\n\t\t\tif (topNode != null) {\r\n\t\t\t\ttopNode.rightmostNode.right = rightmostNode;\r\n\t\t\t\tcurrentNode = topNode.main;\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tswitch (last) {\r\n\t\t\tcase \"operator\":     //Assume the rightmost leaf is null\r\n\t\t\t\tconst term = getSingleTerm(tokens);\r\n\t\t\t\tif (term) {\r\n\t\t\t\t\tlast = \"term\";\r\n\t\t\t\t\tif (rootNode == null) rootNode = currentNode = rightmostNode = new Tree(term);\r\n\t\t\t\t\telse if (rightmostNode == null) currentNode = rightmostNode = new Tree(term);\r\n\t\t\t\t\telse rightmostNode = rightmostNode.right = new Tree(term);\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tif (getLParans(tokens)) {\r\n\t\t\t\t\tparenthesisIndices.push(currentNode && rightmostNode ? { main: currentNode, rightmostNode } : null);\r\n\t\t\t\t\tcurrentNode = rightmostNode = null;\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tif (peekToken(/end/, tokens)) {\r\n\t\t\t\t\tlast = \"operator\";\t//might have removed some + or -\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new SyntaxError(`unexpected token '${tokens.shift()}': value or expression expected.`);\r\n\t\t\tcase \"term\":\r\n\t\t\t\tconst operator = getOperator(tokens)\r\n\t\t\t\tif (operator) {\r\n\t\t\t\t\tif (!rightmostNode) rightmostNode = currentNode;\r\n\t\t\t\t\tlast = \"operator\";\r\n\t\t\t\t\tswitch (getRank(operator)) {\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\tif (rightmostNode) rightmostNode.extend(operator);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\tcurrentNode.extend(operator);\r\n\t\t\t\t\t\t\t\trightmostNode = currentNode;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new SyntaxError(`unexpected token '${tokens.shift()}': operator expected.`);\r\n\t\t}\r\n\t}\r\n\tif (parenthesisIndices.length) throw new SyntaxError(`unexpected end of input : ${last == \"operator\" ? \"value or expression\" : \"operator/closing bracket\"} expected.`);\r\n\tif (last == \"operator\" || rootNode == null) throw new SyntaxError(\"unxpected end of input: value or expression expected\");\r\n\treturn rootNode\r\n}\r\n\r\nfunction add(a: Polynomial | string | number, b: Polynomial | string | number) {\r\n\tlet sum = new Polynomial();\r\n\tif (!isNaN(Number(a)) && !isNaN(Number(b))) {\r\n\t\tsum.add(new Term(new Exponential(Number(a) + Number(b))));\r\n\t\treturn sum\r\n\t}\r\n\tif (!(a instanceof (Polynomial))) a = new Polynomial(new Term(new Exponential(a)));\r\n\tif (!(b instanceof (Polynomial))) b = new Polynomial(new Term(new Exponential(b)));\r\n\tfor (let operand of [a, b]) {\r\n\t\tfor (let term of operand.terms)\r\n\t\t\tsum.add(term);\r\n\t}\r\n\treturn sum;\r\n}\r\n\r\nfunction multiply(a: Polynomial | string | number, b: Polynomial | string | number) {\r\n\tif (!(b instanceof Polynomial)) b = new Polynomial(b);\r\n\tif (!(a instanceof Polynomial)) a = new Polynomial(a);\r\n\tlet product = new Polynomial();\r\n\tfor (let bTerm of b.terms) {\r\n\t\tfor (let aTerm of a.terms)\r\n\t\t\tproduct.add(new Term(...aTerm.variables, new Exponential(aTerm.coefficient), ...bTerm.variables, new Exponential(bTerm.coefficient)));\r\n\t}\r\n\treturn product;\r\n}\r\nfunction divide(a: Polynomial | string | number, b: Polynomial | string | number) {\r\n\tif (!(b instanceof Polynomial)) b = new Polynomial(b);\r\n\tif (!(a instanceof Polynomial)) a = new Polynomial(a);\r\n\tb = raiseToPower(b, new Polynomial(-1));\r\n\tlet product = new Polynomial();\r\n\tfor (let bTerm of b.terms) {\r\n\t\tfor (let aTerm of a.terms)\r\n\t\t\tproduct.add(new Term(...aTerm.variables, new Exponential(aTerm.coefficient), ...bTerm.variables, new Exponential(bTerm.coefficient)));\r\n\t}\r\n\treturn product;\r\n}\r\nfunction subtract(a: Polynomial | string | number, b: Polynomial | string | number) {\r\n\tlet sum = new Polynomial();\r\n\tif (!isNaN(Number(a)) && !isNaN(Number(b))) {\r\n\t\tsum.add(new Term(new Exponential(Number(a) - Number(b))));\r\n\t\treturn sum\r\n\t}\r\n\tif (!(a instanceof (Polynomial))) a = new Polynomial(new Term(new Exponential(a)));\r\n\tif (!(b instanceof (Polynomial))) b = new Polynomial(new Term(new Exponential(b)));\r\n\tfor (const term of a.terms) sum.add(term);\r\n\tfor (let term of b.terms) {\r\n\t\tconst negativeTerm = new Term(new Exponential(-term.coefficient), ...term.variables);\r\n\t\tsum.add(negativeTerm);\r\n\t}\r\n\treturn sum;\r\n}\r\n\r\nfunction raiseToPower(a: Polynomial, b: Polynomial) {\r\n\treturn new Polynomial(new Term(new Exponential(a, b)));\r\n}\r\n\r\nfunction parse(expression: string) {\r\n\tlet tree = getAllTerms(tokenize(expression));\r\n\treturn evaluate(tree);\r\n}\r\nfunction evaluate(tree: Tree<string | number>): Polynomial {\r\n\tif (tree.isLeaf) {\r\n\t\tlet coefficient = (tree.cargo as string)[0] == \"+\" ? 1 : -1;  //if the value has positive or negative sign in front\r\n\t\treturn new Polynomial(new Term(new Exponential(coefficient), new Exponential((tree.cargo as string).substring(1))));\r\n\t} else if (tree.left && tree.right) {\r\n\t\tlet left = evaluate(tree.left);\r\n\t\tlet right = evaluate(tree.right);\r\n\t\tswitch (tree.cargo) {\r\n\t\t\tcase \"*\": return multiply(left, right);\r\n\t\t\tcase \"+\": return add(left, right);\r\n\t\t\tcase \"^\": return raiseToPower(left, right);\r\n\t\t\tcase \"-\": return subtract(left, right);\r\n\t\t\tcase \"/\": return divide(left, right);\r\n\t\t}\r\n\t}\r\n\tthrow new TypeError(`Operator '${tree.cargo} is not yet supported\"`);\r\n}\r\n\r\nconst extensions: { [className: string]: new (...args: any) => any } = {\r\n\t\"Fraction\": Fraction,\r\n\t\"Term\": Term,\r\n\t\"Exponential\": Exponential,\r\n\t\"Polynomial\": Polynomial\r\n}\r\n\r\n\r\nexport {\r\n\tenableForm,\r\n\tdisableForm,\r\n\tfactors,\r\n\tisSquare,\r\n\tmakeWhole,\r\n\tsqRoot,\r\n\tlowestRatios,\r\n\tisFactorOf,\r\n\tmultiply,\r\n\tdivide,\r\n\tcombination,\r\n\tfactorial,\r\n\tFraction,\r\n\tTerm,\r\n\trestorePrototype,\r\n\tparse,\r\n\tgetAllTerms,\r\n\ttokenize,\r\n\tExponential,\r\n\tPolynomial,\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const utils = require(\"../utils\")\r\nexport function convertToBase(number: string, base: number, newBase: number) {\r\n\tlet value;\r\n\tnumber = number.toString().toLowerCase();\r\n\r\n\t//Defensive Assertions\r\n\tif (!(/\\b\\w+\\b/.test(number + base + newBase))) throw new Error(\"Invalid Input\")\r\n\tif (base > 36 || newBase > 36) throw new Error(\"Conversions Above Base 36 Not Supported!\");\r\n\tif (base < 2 || newBase < 2) throw new Error(\"Conversions Below Base 2 Not Supported!\");\r\n\tfor (var i = 0; i < number.length; ++i) { //check if digits in number is within the base range\r\n\t\tif (number.charCodeAt(i) < 58) {\r\n\t\t\tif (Number(base) + 48 <= number.charCodeAt(i)) throw new Error(`${number} Is Not A Base ${base} Number`);\r\n\t\t} else {\r\n\t\t\tif (number.charCodeAt(i) - 87 >= base) throw new Error(`${number} Is Not A Base ${base} Number`);\r\n\t\t}\r\n\t}\r\n\t//MAIN\r\n\r\n\tlet answer = base10ToBaseN(toBase10(number, base), newBase); //convert number to base10, then convert to new base\r\n\treturn answer\r\n\t//HELPER FUNCTIONS\r\n\r\n\tfunction toBase10(number: string | number, base: number) { //converts number to base10# \r\n\t\t\tnumber = number.toString();\r\n\t\tvar wholeResult = 0,\r\n\t\t\tfloatResult = 0,\r\n\t\t\tpointIndex = ~number.indexOf(\".\") ? number.indexOf(\".\") : Infinity;\r\n\t\tlet [whole, float] = [number.slice(0, pointIndex), number.slice(pointIndex + 1)];\r\n\t\tfor (let i = whole.length - 1, j = 0; i >= 0; --i, ++j) {\r\n\t\t\twholeResult += Math.pow(base, j) * (whole.charCodeAt(i) < 58 ? Number(whole[i]) : whole.charCodeAt(i) - 87);\r\n\t\t}\r\n\t\tif (!float) return wholeResult;\r\n\t\tfor (let placeValue: number, digit: number, i = 0, j = 1; i < float.length; ++i, ++j) {\r\n\t\t\tdigit = float.charCodeAt(i) < 58 ? Number(float[i]) : float.charCodeAt(i) - 87;\r\n\t\t\tplaceValue = Math.round(digit / Math.pow(base, j) * Math.pow(10, 15)) / Math.pow(10, 15);\r\n\t\t\tfloatResult = Math.round((floatResult + placeValue) * Math.pow(10, 15)) / Math.pow(10, 15);\r\n\t\t}\r\n\t\treturn Math.round((wholeResult + floatResult) * Math.pow(10, 15)) / Math.pow(10, 15);\r\n\t}\r\n\r\n\tfunction base10ToBaseN(number: number, n: number) { //Assumes number is in base10, converts it to baseN \r\n\t\tif (number > Number.MAX_SAFE_INTEGER) return number.toString(n);\r\n\t\tconst numberFixed = ~String(number).indexOf(\"e\") ? number.toFixed(15).replace(/0+$/, ``) : number.toString();\r\n\t\tlet floatResult, wholeResultDigits = [],\r\n\t\t\tpointIndex = ~numberFixed.indexOf(\".\") ? numberFixed.indexOf(\".\") : Infinity,\r\n\t\t\t[whole, float] = [Number(numberFixed.slice(0, pointIndex)), parseFloat(numberFixed.slice(pointIndex))],\r\n\t\t\tfraction = float ? (new utils.Fraction(float).toLowestTerms()) : null;\r\n\t\twhile (whole > 0) {\r\n\t\t\tlet digit = whole % n;\r\n\t\t\twholeResultDigits.push(digit < 10 ? whole % n : String.fromCharCode(digit + 87));\r\n\t\t\twhole = Math.floor(whole / n);\r\n\t\t}\r\n\t\tconst wholeResult = Number(wholeResultDigits.reverse().join(\"\")) || 0;\r\n\t\tif (fraction) {\r\n\t\t\t//[fraction.nume] = [base10ToBaseN(fraction.nume, n)];\r\n\t\t\tfloatResult = \".\";\r\n\t\t\tlet placeDigit, nume = fraction.nume;\r\n\t\t\tconst d = Number(fraction.denom);\r\n\t\t\twhile ((floatResult.length < 60) /*&& toBase10(wholeResult + ((floatResult+0)||\"\"),n)<Number(number)*/ ) {\r\n\t\t\t\t// nume += 0;\r\n\t\t\t\t// if(Number(toBase10(nume,n))<d){floatResult+=0; continue};\r\n\t\t\t\t// placeDigit = base10ToBaseN(Math.floor(toBase10(nume,n)/d),n);\r\n\t\t\t\t// nume = base10ToBaseN(Number((toBase10(nume,n) % d).toFixed(15)),n);\r\n\t\t\t\t// floatResult += placeDigit;\r\n\r\n\t\t\t\t// This method works too.\r\n\t\t\t\t// let product = Math.round(float * n * Math.pow(10,14))/Math.pow(10,14);\r\n\t\t\t\t// floatResult += base10ToBaseN(Math.floor(product),n);\r\n\t\t\t\t// float = String(product).replace(/^\\d+/,``)\r\n\r\n\t\t\t\tnume *= n;\r\n\t\t\t\tplaceDigit = Math.floor((nume) / d);\r\n\t\t\t\tfloatResult += base10ToBaseN(placeDigit, n)\r\n\t\t\t\tnume = nume % d;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (wholeResult + (floatResult || \"\")).replace(/(\\.\\w+?)0+$/g, \"$1\");\r\n\t}\r\n}\r\n","const primeCache: { [n: number]: number } = { 1: 2, 2: 3, 500000: 7368787, 1000000: 15485863 };\r\nexport function findPrime(x: number) {\r\n\t\tif (isNaN(x) || x < 1 || x > 100000000) throw new Error(\"Input Out Of Range\");\r\n\t\tif (x in primeCache) return primeCache[x];        //if the x prime has been calculated, return the cached answer\r\n\t\tvar count, number, x = Number(x), nearestIndex = Math.floor(x / 5000) * 5000;\r\n\t\tif (nearestIndex in primeCache) {\r\n\t\t\tcount = nearestIndex;\r\n\t\t} else {\r\n\t\t\tcount = Object.keys(primeCache)\r\n\t\t\t.map(x => Number(x))\r\n\t\t\t.reduce(function (least, num) { \r\n\t\t\t\tlet result;\r\n\t\t\t\tif (num < x && num > least) { least = num }; return least; }, 0)\r\n\t\t}\r\n\t\tnumber = primeCache[count];\r\n\t\twhile (count < x) {\r\n\t\t\tif (isPrime(number + 2)) {\r\n\t\t\t\t++count;\r\n\t\t\t\tif (count % 5000 === 0) primeCache[count] = number + 2;\r\n\t\t\t}\r\n\t\t\tnumber += 2;\r\n\t\t}\r\n\t\treturn number\r\n\t}\r\n\r\n\tfunction isPrime(x: number) {\r\n\t\tif (x == 2) return true;\r\n\t\tif (x == 1 || x % 2 == 0) return false;\r\n\t\tvar count = 3, limit = Math.sqrt(x) + 1;\r\n\t\twhile (count < limit) {\r\n\t\t\tif (x % count == 0) return false;\r\n\t\t\tcount += 2;\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n","import { convertToBase } from \"../solvers/baseConverter\";\r\nimport { findPrime } from \"../solvers/prime\";\r\nimport { quadraticRoots } from \"../solvers/quadratic\";\r\nimport { polynomialExpand } from \"../solvers/polynomial\";\r\nonmessage = function (message) {\r\n\tif (message.data._subworker) return;\r\n\tlet\r\n\t\tanswer,\r\n\t\targs: Array<any> = message.data.args,\r\n\t\tfuncName = message.data.funcName,\r\n\t\tmessageId: string = message.data.id;\r\n\ttry {\r\n\t\tswitch (funcName) {\r\n\t\t\tcase \"findPrime\":\r\n\t\t\t\tanswer = findPrime(args[0] as number); break;\r\n\t\t\tcase \"convertToBase\":\r\n\t\t\t\tanswer = convertToBase(args[0] as string, args[1], args[2]); break;\r\n\t\t\tcase \"quadraticRoots\":\r\n\t\t\t\tanswer = quadraticRoots(args[0]); break;\r\n\t\t\tcase \"polynomialExpand\":\r\n\t\t\t\tanswer = polynomialExpand(args[0]);\r\n\r\n\t\t}\r\n\t\tpostMessage({ answer, id: messageId, type: \"answer\" });\r\n\t} catch (error) {\r\n\t\tdispatchError(error, messageId);\r\n\t}\r\n}\r\n\r\nfunction dispatchError(error: any, id: string) {                                                  //dispatches an error from a worker to its creator\r\n\tvar errorClone: {[prop: string]: any}= {}, errorProperties = Object.getOwnPropertyNames(error);\r\n\tfor (let i of errorProperties) {\r\n\t\terrorClone[i] = error[i];\r\n\t}\r\n\tpostMessage({ type: \"error\", errorClone, id });\r\n}","import { Fraction, isSquare, makeWhole, parse, sqRoot } from \"../utils\";\r\nexport function quadraticRoots(func: string){\r\n\t// let variable, illegalToken, variableCheck=/[a-zA-Z]/g;\r\n\t// if(/[a-zA-Z]/.test(func)) var x = variable = /[a-zA-Z]/.exec(func)[0];                                    //the variable in func\r\n\t// else throw new Error(\"Argument Is Not A Quadratic Function.\");\r\n\t// try{\r\n\t// \tlet a_match = ``, b_match = ``, c_match, value;\r\n\t// \tvar b_pattern = new RegExp(`([\\\\+\\\\-](\\\\d*(?:\\\\.\\\\d+)?)?${x}(?![^\\\\+\\\\-]*2))|(^(\\\\d*(?:\\\\.\\\\d+)?)?${x}(?![^\\\\+\\\\-]*2))`),                   //positive/negative integer/decimal number before x but not x(2)\r\n\t// \tc_pattern = new RegExp(`([\\\\+\\\\-](\\\\d+(?:\\\\.\\\\d+)?|(?:\\\\.\\\\d+))(?![${x}\\\\d\\\\.]))|(^((\\\\d+(?:\\\\.\\\\d+)?)|((?:\\\\.\\\\d+)))(?![${x}\\\\d\\\\.]))`),                            //positive/negative integer/decimal no. that doesn't occur before an x\r\n\t// \ta_pattern = new RegExp(`[\\\\+\\\\-]?(\\\\d*(?:\\\\.\\\\d+)?)?${x}\\\\^?\\\\(?2\\\\)?`),                       //positive/negative integer/decimal no. before x(2)\r\n\t// \tfuncWithoutA =func.replace(new RegExp(a_pattern,\"g\"),\"\"),                                      //remove a from func, for c_pattern not to match 2\r\n\t// \ta = (~func.search(a_pattern) && !isNaN(value = parseFloat(a_match = func.match(a_pattern)[0]))? value : \r\n\t// \t~a_match.search(`-${x}`)? -1 : ~a_match.search(`^[\\+]?${x}`)? 1 : 0),\r\n\t// \tb = (~func.search(b_pattern) && !isNaN(value = parseFloat(b_match = func.match(b_pattern)[0]))? value :      //set b to 0 or the occurence of b_pattern\r\n\t// \t~b_match.search(`-${x}`)? -1 : ~b_match.search(`^[\\+]?${x}`)? 1 : 0),\r\n\t// \tc = (c_match = funcWithoutA.match(c_pattern))? parseFloat(c_match[0]) : 0;                     //set c to 0 or the occurence of c_pattern\r\n\t// }\r\n\t// catch(error){\r\n\t// \tif(func==\"\") throw new Error(\"No Arguments Supplied\");\r\n\t// \tthrow new Error(\"Invalid format!\");\r\n\t// }\r\n\t// checkforErrors: {\r\n\t// \twhile(variableCheck.test(func)){\r\n\t// \t\tif(func[variableCheck.lastIndex-1] !== variable) throw new Error(\"Function Is Not In One Variable\");\r\n\t// \t};\r\n\t// \ta_pattern.lastIndex=b_pattern.lastIndex=c_pattern.lastIndex = 0;\r\n\t// \tvariableCheck = /[a-zA-Z]/g;\r\n\t// \tif(!illegalToken){ a_pattern.lastIndex=b_pattern.lastIndex=c_pattern.lastIndex=0;\r\n\t// \t\tif(func.match(/\\(/) && !func.match(/\\)/)) throw new Error (`Invalid Input! Unterminated \\(`);\r\n\t// \t\tif(func.match(/\\)/) && !func.match(/\\(/)) throw new Error(`Invalid Input! Unexpected token \\)`);\r\n\t// \t\tif(illegalToken=func.match(/[\\+\\-][\\+\\-]/) || func.match(/\\)[^\\+\\-]/)) throw new Error(`Invalid Input! Illegal Sequence ${illegalToken}`);\r\n\t// \t\tif(illegalToken=func.replace(a_pattern,\"\").replace(b_pattern,\"\").replace((funcWithoutA.match(c_pattern))? funcWithoutA.match(c_pattern)[0]: \"\",\"\")) throw new Error(`Invalid Input! Unexpected Token ${illegalToken+(func[func.lastIndexOf(illegalToken[illegalToken.length-1])+1]||\" \")}`);\r\n\t// \t}\r\n\t// \tif(a==0) throw new Error(\"Argument Is Not A Quadratic Function\");\r\n\t\t\r\n\t// };\r\n\tvar variable,\r\n\ta = 0,\r\n\tb = 0,\r\n\tc = 0;\r\n\tvar poly = parse(func).flatten();\r\n\tif (poly.multivariable) throw new TypeError(\"Input has more than one variable\");\r\n\tif (poly.degree != 2) throw new TypeError(\"Input is not a quadratic function\");\r\n\tfor (let term of poly.terms) {\r\n\t\tif (!term.variables.length)  {\r\n\t\t\tc = term.coefficient;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (term.variables[0].power == 2) {\r\n\t\t\ta = term.coefficient;\r\n\t\t\tvariable = term.variables[0].base;\r\n\t\t}\r\n\t\telse if (term.variables.length === 1 && term.variables[0].power == 1) b = term.coefficient;\r\n\t\telse throw new TypeError(\"Input is not a quadratic function\");\r\n\t}\r\n\tvar wholes = makeWhole(a,b,c);                                        //make all the coefficients  whole numbers\r\n\t\ta = wholes.numbers[0], b = wholes.numbers[1], c = wholes.numbers[2];\r\n\tlet D = (b * b) - 4 * (a * c);\r\n\tif((D>=0) && isSquare(D)){                       //if determinant is a positive perfect square\r\n\t\tvar ans1num = -b + Math.sqrt(D), ans1 = new Fraction(ans1num,2*a).toLowestTerms();\r\n\t\tvar ans2num = -b - Math.sqrt(D), ans2 = new Fraction(ans2num,2*a).toLowestTerms();\r\n\t\treturn {type:\"simple\",ans1,ans2,variable}\r\n\t}\r\n\telse{\r\n\t\tvar determinant = new Fraction(sqRoot(D),2*a).toLowestTerms();                                    //find the square root of the determinant(in surd/complex form) and divide it by 2a\r\n\t\tdeterminant.nume = determinantNumeFormat(String(determinant.nume));                                         //format the numerator for display. \r\n\t\tvar first = new Fraction(-b,2*a).toLowestTerms();                                                   //divide the first part(-b) by 2a and reduce to lowest terms\r\n\t\treturn {type:\"surd/complex\",first,determinant,variable};\r\n\t}\r\n\t\r\n\t//HELPER FUNCTIONS\r\n\t\r\n\tfunction determinantNumeFormat(nume: string){\r\n\t\tvar f = parseInt(nume);\r\n\t\tif(f) nume = nume.replace(f.toString(), f==1 || f==-1? \"\":f.toString());            //We don't need unity coefficient in front of squareRoot\r\n\t\tif(nume[0]==\"-\") nume = nume.replace(/^-/,\"\");                                 //Because of the (+-) to appear before the numerator, - sign doesn't matter at all\r\n\t\treturn nume\r\n\t};\r\n}\r\n","import { parse } from \"../utils\";\r\n\r\nexport function polynomialExpand(func: string){\r\n\t// let nC, sA, sB, sC;                                               //Numeric coefficient, sign coefficient\r\n\t// var a_match = /[\\+\\-]?\\w+(?=[\\+\\-])/,\r\n\t// b_match = /[\\+\\-]\\w+(?=\\))/,\r\n\t// n_match = /((\\([\\+]?\\d+\\))|([\\+]?\\d+))$/,\r\n\t// n =  n_match.test(func)?  parseInt(n_match.exec(func)[0].replace(/^[^\\+\\-\\d]+/,\"\")): 1,\r\n\t// a = new String(a_match.exec(func)[0]),\r\n\t// b = new String(b_match.exec(func)[0]);\r\n\t// a.sign = b.sign = 1; \r\n\t// if(sC = /^[\\-\\+]/.exec(a)){                           //if a is prefixed with a sign, \r\n\t// \ta = new String(a.replace(sC[0],\"\"));              // remove the sign and multiply the coefficient by it\r\n\t// \ta.sign =  sC[0]+1;\r\n\t// }\r\n\t// if(sC = /^[\\-\\+]/.exec(b)){\r\n\t// \tb = new String(b.replace(sC[0],\"\"));\r\n\t// \tb.sign =  sC[0]+1;\r\n\t// }\r\n\t// if(nC=parseInt(a)){\r\n\t// \tlet sign = a.sign;\r\n\t// \ta = new String(a.replace(/^[\\+\\-]?\\d+/,\"\"))\r\n\t// \tsign? (a.sign = sign*nC): (a.sign = nC); \r\n\t// }\r\n\t// if(nC=parseInt(b)){\r\n\t// \tlet sign = b.sign;\r\n\t// \tb = new String(b.replace(/^[\\+\\-]?\\d+/,\"\"))\r\n\t// \tsign? (b.sign = sign*nC): (b.sign = nC); \r\n\t// }\r\n\t// if((sA = new Set(a)).size != a.length){\r\n\t// \tlet duplicates = a;\r\n\t// \tfor(let i of sA){\r\n\t// \t\tduplicates = duplicates.replace(i,\"\");\r\n\t// \t}\r\n\t// \tif(duplicates) throw new Error(`Duplicates {${Array.from(new Set(duplicates)).join()}} not allowed in left variable`)\r\n\t// };\r\n\t// if((sB = new Set(b)).size != b.length){\r\n\t// \tlet duplicates = b;\r\n\t// \tfor(let i of sB){\r\n\t// \t\tduplicates = duplicates.replace(i,\"\");\r\n\t// \t}\r\n\t// \tif(duplicates) throw new Error(`Duplicates {${Array.from(new Set(duplicates)).join()}} not allowed in right variable`)\r\n\t// }\r\n\t\r\n\r\n\t\r\n\t// let  power = 0, terms = [];\r\n\t// while(power<=n){\r\n\t// \tlet\r\n\t// \t\tcoefficient = utils.combination(n,power)*Math.pow(a.sign,n-power)*Math.pow(b.sign,power),                  //n Combination p\r\n\t// \t\tfvar = new utils.Exponential(a,n-power),                     //set first variable to a^(n-p)\r\n\t// \t\tsvar = new utils.Exponential(b,power);                       //set Second variable to b^(p)\r\n\t// \t\tterms.push(new utils.Term(coefficient,fvar,svar));         //collect all in a new term.\r\n\t// \t\t++power\r\n\t// };\r\n\t// return terms;\r\n\treturn parse(func).flatten().terms;\r\n};\r\n"],"names":["restorePrototype","obj","extension","__proto__","extensions","prototype","prop","disableForm","form","Array","forEach","call","elements","e","disabled","readOnly","type","style","cursor","enableForm","factorsCache","length","Object","keys","this","factors","x","Math","abs","answer","increment","i","floor","sqrt","right","left","m","n","p","q","push","Set","reduce","list","every","s","sort","a","b","isSquare","sqr","makeWhole","numbers","formattedNumbers","map","String","indexOf","toFixed","replace","toString","highestDecimalDigits","Number","isInteger","h","max","decimalDigits","round","pow","sqRoot","nP","result","nP_fcList","j","lowestRatios","fctList","min","isFactorOf","bind","combination","factorial","count","ans","Fraction","constructor","nume","denom","arguments","whole","toLowestTerms","t","d","top","bottom","reducedRatios","isNaN","parseFloat","valueOf","Term","args","index","coefficient","splice","variables","product","arg","processedArg","compareBase","Exponential","base","add","power","processedvariable","argvariable","toAdd","already","comparePower","isString","multiply","localeCompare","isAddable","other","outerLoop","thisVariable","otherVariable","flatten","variable","cumulativeProduct","pol","Polynomial","str","Tree","cargo","_toFormat","tree","width","height","offset","isLeaf","repeat","Error","replaceNode","node","newNode","currentTreeNode","getRightMost","rightMost","extend","value","previousValue","print","indent","console","log","terms","processTerms","term","variableLetters","letter","split","processedTerm","sum","NaN","thisTerms","otherTerms","thisTerm","otherTerm","allTerms","termsa","termsb","concat","multivariable","size","degree","join","compareComponents","flattenedBase","newExp","simplifiedPower","flattenedPower","tokenize","expr","tokens","lastIndex","numberMatcher","exec","slice","getToken","token","test","shift","peekToken","getSingleTerm","number","sign","getOperator","getLParans","getRParans","getRank","operator","getAllTerms","rootNode","currentNode","rightmostNode","parenthesisIndices","last","SyntaxError","topNode","pop","main","operand","bTerm","aTerm","divide","raiseToPower","parse","expression","evaluate","substring","negativeTerm","subtract","TypeError","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","definition","key","o","defineProperty","enumerable","get","hasOwnProperty","r","Symbol","toStringTag","utils","primeCache","isPrime","limit","onmessage","message","data","_subworker","funcName","messageId","id","nearestIndex","least","num","findPrime","newBase","toLowerCase","charCodeAt","base10ToBaseN","MAX_SAFE_INTEGER","numberFixed","floatResult","wholeResultDigits","pointIndex","Infinity","float","fraction","digit","fromCharCode","wholeResult","reverse","placeDigit","placeValue","toBase10","convertToBase","func","c","poly","wholes","D","ans1num","ans1","ans2num","ans2","f","determinant","parseInt","first","quadraticRoots","postMessage","error","errorClone","errorProperties","getOwnPropertyNames","dispatchError"],"sourceRoot":""}